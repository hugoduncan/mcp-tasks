name: Build Native Binaries

on:
  workflow_call:
  workflow_dispatch:

jobs:
  test:
    name: Test and Lint
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Clojure environment
        uses: ./.github/actions/setup-clojure
        with:
          java-distribution: 'temurin'
          install-linters: 'true'

      - name: Run cljstyle check
        run: cljstyle check

      - name: Run clj-kondo lint
        run: clj-kondo --lint src test --fail-level warning

      - name: Run unit tests
        run: clojure -M:dev:test --focus :unit

      - name: Run integration tests
        run: clojure -M:dev:test --focus :integration --skip-meta :native-binary

  build-matrix:
    name: Build ${{ matrix.os }}-${{ matrix.arch }}
    needs: test
    runs-on: ${{ matrix.runner }}
    strategy:
      matrix:
        include:
          - os: linux
            arch: amd64
            runner: ubuntu-latest
          - os: macos
            arch: universal
            runner: macos-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Clojure environment
        uses: ./.github/actions/setup-clojure
        with:
          java-distribution: 'graalvm'
          cache-key-suffix: '${{ matrix.os }}-${{ matrix.arch }}-'
          github-token: ${{ secrets.GITHUB_TOKEN }}

      - name: Build CLI JAR
        run: clojure -T:build jar-cli

      - name: Validate CLI JAR contains manifest and prompts
        run: |
          JAR_FILE=$(ls target/mcp-tasks-cli-*.jar | head -1)
          echo "Validating JAR: $JAR_FILE"

          # Verify prompts-manifest.edn exists
          if ! jar tf "$JAR_FILE" | grep -q "^prompts-manifest.edn$"; then
            echo "Error: prompts-manifest.edn not found in JAR"
            exit 1
          fi
          echo "✓ prompts-manifest.edn found"

          # Verify workflow prompts exist (count derived from manifest)
          EXPECTED_COUNT=$(jar xf "$JAR_FILE" prompts-manifest.edn && cat prompts-manifest.edn | grep -o '"[^"]*"' | wc -l && rm prompts-manifest.edn)
          WORKFLOW_COUNT=$(jar tf "$JAR_FILE" | grep "^prompts/.*\.md$" | wc -l)
          if [ "$WORKFLOW_COUNT" -lt "$EXPECTED_COUNT" ]; then
            echo "Error: Expected at least $EXPECTED_COUNT workflow prompts (from manifest), found $WORKFLOW_COUNT"
            exit 1
          fi
          echo "✓ Found $WORKFLOW_COUNT workflow prompts (expected: $EXPECTED_COUNT)"

          # Verify category prompts exist
          CATEGORY_COUNT=$(jar tf "$JAR_FILE" | grep "^category-prompts/.*\.md$" | wc -l)
          if [ "$CATEGORY_COUNT" -lt 4 ]; then
            echo "Error: Expected at least 4 category prompts, found $CATEGORY_COUNT"
            exit 1
          fi
          echo "✓ Found $CATEGORY_COUNT category prompts"

      - name: Build native CLI binary
        run: |
          if [ "${{ matrix.arch }}" = "universal" ]; then
            clojure -T:build native-cli :universal true
          else
            clojure -T:build native-cli
          fi

      - name: Build Server JAR
        run: clojure -T:build jar-server

      - name: Validate Server JAR contains manifest and prompts
        run: |
          JAR_FILE=$(ls target/mcp-tasks-server-*.jar | head -1)
          echo "Validating JAR: $JAR_FILE"

          # Verify prompts-manifest.edn exists
          if ! jar tf "$JAR_FILE" | grep -q "^prompts-manifest.edn$"; then
            echo "Error: prompts-manifest.edn not found in JAR"
            exit 1
          fi
          echo "✓ prompts-manifest.edn found"

          # Verify workflow prompts exist (count derived from manifest)
          EXPECTED_COUNT=$(jar xf "$JAR_FILE" prompts-manifest.edn && cat prompts-manifest.edn | grep -o '"[^"]*"' | wc -l && rm prompts-manifest.edn)
          WORKFLOW_COUNT=$(jar tf "$JAR_FILE" | grep "^prompts/.*\.md$" | wc -l)
          if [ "$WORKFLOW_COUNT" -lt "$EXPECTED_COUNT" ]; then
            echo "Error: Expected at least $EXPECTED_COUNT workflow prompts (from manifest), found $WORKFLOW_COUNT"
            exit 1
          fi
          echo "✓ Found $WORKFLOW_COUNT workflow prompts (expected: $EXPECTED_COUNT)"

          # Verify category prompts exist
          CATEGORY_COUNT=$(jar tf "$JAR_FILE" | grep "^category-prompts/.*\.md$" | wc -l)
          if [ "$CATEGORY_COUNT" -lt 4 ]; then
            echo "Error: Expected at least 4 category prompts, found $CATEGORY_COUNT"
            exit 1
          fi
          echo "✓ Found $CATEGORY_COUNT category prompts"

      - name: Build native server binary
        run: |
          if [ "${{ matrix.arch }}" = "universal" ]; then
            clojure -T:build native-server :universal true
          else
            clojure -T:build native-server
          fi

      - name: Set binary name
        id: binary-name
        run: echo "binary-name=mcp-tasks-${{ matrix.os }}-${{ matrix.arch }}" >> $GITHUB_OUTPUT

      - name: Verify binary architecture
        run: |
          if [ "${{ matrix.os }}" = "macos" ] && [ "${{ matrix.arch }}" = "universal" ]; then
            echo "Verifying universal binary contains both architectures..."
            file target/${{ steps.binary-name.outputs.binary-name }}
            if ! file target/${{ steps.binary-name.outputs.binary-name }} | grep -q "x86_64"; then
              echo "Error: Binary missing x86_64 architecture"
              exit 1
            fi
            if ! file target/${{ steps.binary-name.outputs.binary-name }} | grep -q "arm64"; then
              echo "Error: Binary missing arm64 architecture"
              exit 1
            fi
            echo "✓ Universal binary verified: contains both x86_64 and arm64"
          elif [ "${{ matrix.os }}" = "linux" ] && [ "${{ matrix.arch }}" = "amd64" ]; then
            echo "Verifying Linux binary is x86_64..."
            file target/${{ steps.binary-name.outputs.binary-name }}
            if ! file target/${{ steps.binary-name.outputs.binary-name }} | grep -q "x86-64"; then
              echo "Error: Binary is not x86_64 architecture"
              exit 1
            fi
            if file target/${{ steps.binary-name.outputs.binary-name }} | grep -q "arm64\|aarch64"; then
              echo "Error: Binary incorrectly contains ARM architecture"
              exit 1
            fi
            echo "✓ Linux binary verified: x86_64 architecture"
          fi

      - name: Upload CLI binary artifact
        uses: actions/upload-artifact@v4
        with:
          name: ${{ steps.binary-name.outputs.binary-name }}
          path: target/${{ steps.binary-name.outputs.binary-name }}
          if-no-files-found: error

      - name: Set server binary name
        id: server-binary-name
        run: echo "server-binary-name=mcp-tasks-server-${{ matrix.os }}-${{ matrix.arch }}" >> $GITHUB_OUTPUT

      - name: Verify server binary architecture
        run: |
          if [ "${{ matrix.os }}" = "macos" ] && [ "${{ matrix.arch }}" = "universal" ]; then
            echo "Verifying universal server binary contains both architectures..."
            file target/${{ steps.server-binary-name.outputs.server-binary-name }}
            if ! file target/${{ steps.server-binary-name.outputs.server-binary-name }} | grep -q "x86_64"; then
              echo "Error: Server binary missing x86_64 architecture"
              exit 1
            fi
            if ! file target/${{ steps.server-binary-name.outputs.server-binary-name }} | grep -q "arm64"; then
              echo "Error: Server binary missing arm64 architecture"
              exit 1
            fi
            echo "✓ Universal server binary verified: contains both x86_64 and arm64"
          elif [ "${{ matrix.os }}" = "linux" ] && [ "${{ matrix.arch }}" = "amd64" ]; then
            echo "Verifying Linux server binary is x86_64..."
            file target/${{ steps.server-binary-name.outputs.server-binary-name }}
            if ! file target/${{ steps.server-binary-name.outputs.server-binary-name }} | grep -q "x86-64"; then
              echo "Error: Server binary is not x86_64 architecture"
              exit 1
            fi
            if file target/${{ steps.server-binary-name.outputs.server-binary-name }} | grep -q "arm64\|aarch64"; then
              echo "Error: Server binary incorrectly contains ARM architecture"
              exit 1
            fi
            echo "✓ Linux server binary verified: x86_64 architecture"
          fi

      - name: Upload server binary artifact
        uses: actions/upload-artifact@v4
        with:
          name: ${{ steps.server-binary-name.outputs.server-binary-name }}
          path: target/${{ steps.server-binary-name.outputs.server-binary-name }}
          if-no-files-found: error

  test-binaries:
    name: Test ${{ matrix.os }}-${{ matrix.arch }} Binary
    needs: build-matrix
    runs-on: ${{ matrix.runner }}
    strategy:
      matrix:
        include:
          - os: linux
            arch: amd64
            runner: ubuntu-latest
            test-focus: comprehensive
          - os: macos
            arch: universal
            runner: macos-latest
            test-focus: smoke

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Clojure environment
        uses: ./.github/actions/setup-clojure
        with:
          java-distribution: 'temurin'
          cache-key-suffix: '${{ matrix.os }}-${{ matrix.arch }}-'

      - name: Download CLI binary artifact
        uses: actions/download-artifact@v4
        with:
          name: mcp-tasks-${{ matrix.os }}-${{ matrix.arch }}
          path: target/

      - name: Download server binary artifact
        uses: actions/download-artifact@v4
        with:
          name: mcp-tasks-server-${{ matrix.os }}-${{ matrix.arch }}
          path: target/

      - name: Make CLI binary executable
        run: chmod +x target/mcp-tasks-${{ matrix.os }}-${{ matrix.arch }}

      - name: Make server binary executable
        run: chmod +x target/mcp-tasks-server-${{ matrix.os }}-${{ matrix.arch }}

      - name: Run smoke tests
        if: matrix.test-focus == 'smoke'
        env:
          BINARY_TARGET_OS: ${{ matrix.os }}
          BINARY_TARGET_ARCH: ${{ matrix.arch }}
        run: clojure -M:dev:test --focus :native-binary --skip-meta :comprehensive

      - name: Run comprehensive tests
        if: matrix.test-focus == 'comprehensive'
        env:
          BINARY_TARGET_OS: ${{ matrix.os }}
          BINARY_TARGET_ARCH: ${{ matrix.arch }}
        run: clojure -M:dev:test --focus :native-binary
