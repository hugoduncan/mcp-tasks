#!/usr/bin/env bb
(ns mcp-tasks.config
  "Configuration management for mcp-tasks"
  (:require
    [babashka.fs :as fs]
    [clojure.edn :as edn]
    [clojure.string :as str]))

(defn validate-config
  "Validates config map structure.
  Returns config if valid, throws ex-info with descriptive error otherwise."
  [config]
  (when-not (map? config)
    (throw (ex-info "Config must be a map"
                    {:type :invalid-config
                     :config config})))
  (when-let [use-git (:use-git? config)]
    (when-not (boolean? use-git)
      (throw (ex-info (str "Expected boolean for :use-git?, got " (type use-git))
                      {:type :invalid-config-type
                       :key :use-git?
                       :value use-git
                       :expected 'boolean?}))))
  (when-let [branch-mgmt (:branch-management? config)]
    (when-not (boolean? branch-mgmt)
      (throw (ex-info (str "Expected boolean for :branch-management?, got " (type branch-mgmt))
                      {:type :invalid-config-type
                       :key :branch-management?
                       :value branch-mgmt
                       :expected 'boolean?}))))
  (when-let [worktree-mgmt (:worktree-management? config)]
    (when-not (boolean? worktree-mgmt)
      (throw (ex-info (str "Expected boolean for :worktree-management?, got " (type worktree-mgmt))
                      {:type :invalid-config-type
                       :key :worktree-management?
                       :value worktree-mgmt
                       :expected 'boolean?}))))
  (when-let [worktree-prefix (:worktree-prefix config)]
    (when-not (keyword? worktree-prefix)
      (throw (ex-info (str "Expected keyword for :worktree-prefix, got " (type worktree-prefix))
                      {:type :invalid-config-type
                       :key :worktree-prefix
                       :value worktree-prefix
                       :expected 'keyword?})))
    (when-not (#{:project-name :none} worktree-prefix)
      (throw (ex-info (str "Invalid value for :worktree-prefix, must be :project-name or :none, got " worktree-prefix)
                      {:type :invalid-config-value
                       :key :worktree-prefix
                       :value worktree-prefix
                       :expected #{:project-name :none}}))))
  (when-let [base-branch (:base-branch config)]
    (when-not (string? base-branch)
      (throw (ex-info (str "Expected string for :base-branch, got " (type base-branch))
                      {:type :invalid-config-type
                       :key :base-branch
                       :value base-branch
                       :expected 'string?})))
    (when (empty? base-branch)
      (throw (ex-info "Value for :base-branch cannot be empty string"
                      {:type :invalid-config-value
                       :key :base-branch
                       :value base-branch}))))
  (when-let [tasks-dir (:tasks-dir config)]
    (when-not (string? tasks-dir)
      (throw (ex-info (str "Expected string for :tasks-dir, got " (type tasks-dir))
                      {:type :invalid-config-type
                       :key :tasks-dir
                       :value tasks-dir
                       :expected 'string?}))))
  (when-let [lock-timeout (:lock-timeout-ms config)]
    (when-not (int? lock-timeout)
      (throw (ex-info (str "Expected integer for :lock-timeout-ms, got " (type lock-timeout))
                      {:type :invalid-config-type
                       :key :lock-timeout-ms
                       :value lock-timeout
                       :expected 'int?})))
    (when-not (pos? lock-timeout)
      (throw (ex-info "Value for :lock-timeout-ms must be positive"
                      {:type :invalid-config-value
                       :key :lock-timeout-ms
                       :value lock-timeout}))))
  (when-let [poll-interval (:lock-poll-interval-ms config)]
    (when-not (int? poll-interval)
      (throw (ex-info (str "Expected integer for :lock-poll-interval-ms, got " (type poll-interval))
                      {:type :invalid-config-type
                       :key :lock-poll-interval-ms
                       :value poll-interval
                       :expected 'int?})))
    (when-not (pos? poll-interval)
      (throw (ex-info "Value for :lock-poll-interval-ms must be positive"
                      {:type :invalid-config-value
                       :key :lock-poll-interval-ms
                       :value poll-interval}))))
  ;; :branch-title-words can be nil (unlimited words) or a positive integer
  (when-let [branch-title-words (:branch-title-words config)]
    (when-not (int? branch-title-words)
      (throw (ex-info (str "Expected integer for :branch-title-words, got " (type branch-title-words))
                      {:type :invalid-config-type
                       :key :branch-title-words
                       :value branch-title-words
                       :expected 'int?})))
    (when-not (pos? branch-title-words)
      (throw (ex-info "Value for :branch-title-words must be positive"
                      {:type :invalid-config-value
                       :key :branch-title-words
                       :value branch-title-words}))))
  config)

(defn find-config-file
  "Searches for .mcp-tasks.edn by traversing up the directory tree from start-dir.
  Returns {:config-file <path> :config-dir <dir>} when found, nil otherwise.
  Resolves symlinks in paths using fs/canonicalize.

  Parameters:
  - start-dir (optional): Directory to start search from. Defaults to CWD."
  ([]
   (find-config-file (System/getProperty "user.dir")))
  ([start-dir]
   (loop [dir (fs/canonicalize start-dir)]
     (when dir
       (let [config-file (fs/file dir ".mcp-tasks.edn")]
         (if (fs/exists? config-file)
           {:config-file (str (fs/canonicalize config-file))
            :config-dir (str dir)}
           (recur (fs/parent dir))))))))

(defn read-config
  "Searches for and reads .mcp-tasks.edn from current directory or parent directories.
  Returns map with :raw-config, :config-dir, and :start-dir.
  If no config file found, returns {:raw-config {} :config-dir <start-dir> :start-dir <start-dir>}.
  Throws ex-info with clear message for malformed EDN or invalid schema.

  Parameters:
  - start-dir (optional): Directory to start search from. Defaults to CWD."
  ([]
   (read-config (System/getProperty "user.dir")))
  ([start-dir]
   (let [canonical-start-dir (str (fs/canonicalize start-dir))]
     (if-let [{:keys [config-file config-dir]} (find-config-file start-dir)]
       (try
         (let [config (edn/read-string (slurp config-file))]
           {:raw-config (validate-config config)
            :config-dir config-dir
            :start-dir canonical-start-dir})
         (catch clojure.lang.ExceptionInfo e
           ;; Re-throw validation errors as-is
           (throw e))
         (catch Exception e
           ;; Wrap EDN parsing errors with context
           (throw (ex-info (str "Failed to parse .mcp-tasks.edn: " (.getMessage e))
                           {:type :malformed-edn
                            :file config-file
                            :cause e}
                           e))))
       ;; No config file found, use defaults
       {:raw-config {}
        :config-dir canonical-start-dir
        :start-dir canonical-start-dir}))))

;; Git auto-detection

(defn git-repo-exists?
  "Checks if .mcp-tasks/.git directory exists in the config directory.
  Returns true if the git repository exists, false otherwise."
  [config-dir]
  (let [git-dir (str config-dir "/.mcp-tasks/.git")]
    (fs/exists? git-dir)))

(defn determine-git-mode
  "Determines whether to use git mode based on config and auto-detection.
  Returns boolean indicating if git mode should be enabled.

  Precedence:
  1. Explicit config value (:use-git?) if present
  2. Auto-detected presence of .mcp-tasks/.git directory"
  [config-dir config]
  (if (contains? config :use-git?)
    (:use-git? config)
    (git-repo-exists? config-dir)))

(defn resolve-tasks-dir
  "Resolves :tasks-dir to an absolute canonical path.

  Resolution logic:
  - If :tasks-dir is absolute → canonicalize and use as-is
  - If :tasks-dir is relative → resolve relative to config-dir
  - If :tasks-dir not specified → default to .mcp-tasks relative to config-dir

  Validates that explicitly specified :tasks-dir exists.
  Default .mcp-tasks doesn't need to exist yet."
  [config-dir config]
  (let [tasks-dir (:tasks-dir config ".mcp-tasks")
        resolved-path (if (fs/absolute? tasks-dir)
                        tasks-dir
                        (str config-dir "/" tasks-dir))]
    ;; Validate explicitly specified paths exist
    (when (and (contains? config :tasks-dir)
               (not (fs/exists? resolved-path)))
      (throw (ex-info (str "Configured :tasks-dir does not exist: " tasks-dir "\n\n"
                           "Resolved path: " resolved-path "\n"
                           "Config directory: " config-dir "\n\n"
                           "Suggestions:\n"
                           "  - Create the directory if this path is intended\n"
                           "  - Check for typos in the :tasks-dir value\n"
                           "  - Note: relative paths are resolved from the config file directory, not CWD")
                      {:type :invalid-config-value
                       :key :tasks-dir
                       :value tasks-dir
                       :resolved-path resolved-path
                       :config-dir config-dir})))
    ;; Return canonical path if it exists, otherwise return resolved path
    (if (fs/exists? resolved-path)
      (str (fs/canonicalize resolved-path))
      resolved-path)))

(defn in-worktree?
  "Returns true if dir is a git worktree (not main repo).
  In worktrees, .git is a file pointing to the main repo, not a directory."
  [dir]
  (let [git-file (fs/file dir ".git")]
    (and (fs/exists? git-file)
         (not (fs/directory? git-file)))))

(defn validate-git-repository-path
  "Validates that a path is a valid git repository (main repo, not worktree).
  
  Checks:
  - Path exists
  - .git exists in path
  - .git is a directory (not a file, which indicates a worktree)
  
  Returns nil if valid, or throws ex-info with descriptive error.
  
  Parameters:
  - path: Directory path to validate
  - context-info: Map with additional context for error messages (optional)"
  ([path]
   (validate-git-repository-path path {}))
  ([path context-info]
   {:pre [(string? path)
          (not (str/blank? path))]}
   (let [canonical-path (str (fs/canonicalize path))]
     ;; Check if path exists
     (when-not (fs/exists? path)
       (throw (ex-info
                (str "Repository path does not exist: " canonical-path)
                (merge {:extracted-path canonical-path} context-info))))

     ;; Check if .git exists
     (let [git-path (fs/file path ".git")]
       (when-not (fs/exists? git-path)
         (throw (ex-info
                  (str "Path is not a valid git repository (missing .git): " canonical-path)
                  (merge {:extracted-path canonical-path} context-info))))

       ;; Check if .git is a directory (not a file indicating a worktree)
       (when-not (fs/directory? git-path)
         (throw (ex-info
                  (str "Path is a nested worktree (expected .git directory, found file): " canonical-path)
                  (merge {:extracted-path canonical-path
                          :git-path (str git-path)}
                         context-info)))))
     nil)))

(defn find-main-repo
  "Extracts main repo path from .git file in worktree.
  The .git file contains: gitdir: /path/to/main/.git/worktrees/name
  Returns the main repository root directory.

  Throws ex-info if:
  - The .git file format is malformed
  - The extracted path doesn't exist
  - The path isn't a valid git repository"
  [worktree-dir]
  {:pre [(string? worktree-dir)
         (not (str/blank? worktree-dir))]}
  (let [git-file (fs/file worktree-dir ".git")
        content (slurp git-file)
        ;; Extract path from "gitdir: /path/to/main/.git/worktrees/name"
        gitdir-match (re-find #"gitdir:\s*(.+)" content)]
    (if gitdir-match
      (let [gitdir-path (second gitdir-match)
            ;; Navigate from .git/worktrees/name to main repo root
            ;; .git/worktrees/name -> .git/worktrees -> .git -> main-repo-root
            main-git-dir (-> gitdir-path
                             fs/parent ; .git/worktrees
                             fs/parent) ; .git
            main-repo-root (fs/parent main-git-dir)
            canonical-path (str (fs/canonicalize main-repo-root))]

        ;; Validate repository using helper
        (validate-git-repository-path
          canonical-path
          {:worktree-dir worktree-dir
           :git-file (str git-file)})

        canonical-path)
      ;; Malformed .git file - provide helpful error message
      (throw (ex-info
               "Malformed .git file in worktree. Expected format: 'gitdir: /path/to/.git/worktrees/name'"
               {:worktree-dir worktree-dir
                :git-file (str git-file)
                :content content})))))

(defn find-main-repo-in-subdirs
  "Searches for main git repository in subdirectories when base-dir has no .git.

  Common pattern: config in parent directory with main repo as subdirectory.
  Example structure:
    /project/
      .mcp-tasks.edn
      project-main/  <- main repo
      worktree-1/
      worktree-2/

  Search strategy:
  1. Look for directories matching *-main pattern
  2. Look for directory named 'bare'
  3. Check each for valid .git directory

  Returns path to main repo if found, nil otherwise."
  [base-dir]
  {:pre [(string? base-dir)
         (not (str/blank? base-dir))]}
  (when (fs/directory? base-dir)
    (let [candidates (concat
                       ;; Look for *-main directories
                       (fs/glob base-dir "*-main")
                       ;; Look for 'bare' directory
                       (when (fs/exists? (fs/file base-dir "bare"))
                         [(fs/file base-dir "bare")]))
          ;; Filter to only directories with .git subdirectory
          main-repos (filter (fn [dir]
                               (and (fs/directory? dir)
                                    (fs/directory? (fs/file dir ".git"))))
                             candidates)]
      (when (seq main-repos)
        ;; Return first match, canonicalized
        (fs/canonicalize (first main-repos))))))

(defn resolve-config
  "Returns final config map with :use-git?, :base-dir, :main-repo-dir, and :resolved-tasks-dir resolved.
  Uses explicit config value if present, otherwise auto-detects from git
  repo presence. Base directory is set to start-dir (current working directory).
  Main repo directory is determined by checking worktree status of base-dir.

  Main repo resolution logic:
  - If base-dir is a worktree → find main repo from base-dir
  - Otherwise → use base-dir as main repo

  This handles cases where:
  - Starting from a worktree directory (config inherited or local)
  - Starting from the main repository directory
  - Normal non-worktree repositories

  When :worktree-management? is true, automatically enables :branch-management?.
  When :worktree-prefix is not set, defaults to :project-name.

  Defaults:
  - :worktree-prefix defaults to :project-name if not set
  - :lock-timeout-ms defaults to 30000 (30 seconds) if not set
  - :lock-poll-interval-ms defaults to 100 (100 milliseconds) if not set
  - :enable-git-sync? defaults to :use-git? value if not set
  
  Parameters:
  - config-dir: Directory where config file was found
  - config: Raw configuration map
  - start-dir (optional): Directory where config search started. Defaults to config-dir."
  ([config-dir config]
   (resolve-config config-dir config config-dir))
  ([config-dir config start-dir]
   (let [;; base-dir represents the current working directory (canonicalized start-dir)
         ;; This is where operations like git status should run
         base-dir (str (fs/canonicalize start-dir))

         ;; Determine main repo directory for repository-wide operations
         ;; Strategy: Check if base-dir (which is start-dir) is a worktree
         ;;
         ;; This handles three scenarios:
         ;; 1. Config in worktree:
         ;;    - start-dir = worktree (e.g., /projects/mcp-tasks-fix-bug/)
         ;;    - config-dir = worktree (same as start-dir)
         ;;    - base-dir = start-dir = worktree
         ;;    - in-worktree?(base-dir) → true → use find-main-repo
         ;;
         ;; 2. Config inherited (config in parent, running in worktree):
         ;;    - start-dir = worktree (e.g., /projects/mcp-tasks-fix-bug/)
         ;;    - config-dir = parent directory (e.g., /projects/mcp-tasks/)
         ;;    - base-dir = start-dir = worktree
         ;;    - in-worktree?(base-dir) → true → use find-main-repo
         ;;
         ;; 3. Started from parent directory (no .git):
         ;;    - start-dir = parent (e.g., /projects/mcp-tasks/)
         ;;    - config-dir = parent (same as start-dir)
         ;;    - base-dir = start-dir = parent (no .git)
         ;;    - in-worktree?(base-dir) → false
         ;;    - Look for main repo in subdirectories (*-main, bare)
         ;;
         ;; Both cases 1 and 2 are handled identically because base-dir is always set
         ;; to start-dir, regardless of where the config file was found.
         ;; The key insight: we care about WHERE WE'RE RUNNING (start-dir),
         ;; not where the config file is located (config-dir).
         main-repo-dir (cond
                         ;; Case 1 & 2: In a worktree
                         (in-worktree? base-dir)
                         (find-main-repo base-dir)

                         ;; Case 3a: Has .git directory (normal repo)
                         (git-repo-exists? base-dir)
                         base-dir

                         ;; Case 3b: No .git - search subdirectories
                         :else
                         (or (find-main-repo-in-subdirs base-dir)
                             base-dir)) ; fallback to base-dir if nothing found

         resolved-tasks-dir (resolve-tasks-dir config-dir config)
         config-with-branch-mgmt (if (:worktree-management? config)
                                   (assoc config :branch-management? true)
                                   config)
         use-git-value (determine-git-mode config-dir config)
         config-with-defaults (cond-> config-with-branch-mgmt
                                (not (contains? config-with-branch-mgmt :worktree-prefix))
                                (assoc :worktree-prefix :project-name)

                                (not (contains? config-with-branch-mgmt :lock-timeout-ms))
                                (assoc :lock-timeout-ms 30000)

                                (not (contains? config-with-branch-mgmt :lock-poll-interval-ms))
                                (assoc :lock-poll-interval-ms 100)

                                (not (contains? config-with-branch-mgmt :enable-git-sync?))
                                (assoc :enable-git-sync? use-git-value))]
     (assoc config-with-defaults
            :use-git? use-git-value
            :base-dir base-dir
            :main-repo-dir main-repo-dir
            :resolved-tasks-dir resolved-tasks-dir))))

;; Startup validation

(defn validate-git-repo
  "Validates that git repository exists when git mode is enabled.
  Returns nil on success.
  Throws ex-info with clear message if validation fails."
  [config-dir config]
  (when (:use-git? config)
    (when-not (git-repo-exists? config-dir)
      (throw (ex-info "Git mode enabled but .mcp-tasks/.git not found"
                      {:type :git-repo-missing
                       :config-dir config-dir
                       :git-dir (str config-dir "/.mcp-tasks/.git")}))))
  nil)

(defn validate-startup
  "Performs all startup validation (config + git repo).
  Returns nil on success.
  Throws ex-info with clear message if any validation fails."
  [config-dir config]
  (validate-git-repo config-dir config)
  nil)
(ns mcp-tasks.cli.parse
  "Argument parsing for the CLI.

  Uses babashka.cli to parse command-line arguments."
  (:require
    [babashka.cli :as cli]
    [cheshire.core :as json]
    [clojure.string :as str]))

;; Help Text

(def help-text
  "Help text for the CLI."
  "mcp-tasks - Task management from the command line

USAGE:
  clojure -M:cli <command> [options]

COMMANDS:
  list      List tasks with optional filters
  show      Display a single task by ID
  add       Create a new task
  complete  Mark a task as complete
  update    Update task fields
  delete    Delete a task

GLOBAL OPTIONS:
  --format <format>     Output format: edn, json, human (default: edn)
  --help                Show this help message

CONFIG DISCOVERY:
  Configuration is discovered automatically - no --config-path option needed.

  The CLI searches for .mcp-tasks.edn starting from the current directory
  and traversing up the directory tree until found or reaching the filesystem
  root. This allows you to invoke the CLI from any subdirectory within your
  project.

  Example:
    # Your project structure:
    # /project/.mcp-tasks.edn
    # /project/src/
    # /project/test/

    # You can run from any directory:
    cd /project/src
    clojure -M:cli list    # Finds /project/.mcp-tasks.edn automatically

Run 'clojure -M:cli <command> --help' for command-specific options.

EXAMPLES:
  clojure -M:cli list --status open --format human
  clojure -M:cli show --task-id 42
  clojure -M:cli add --category simple --title \"Fix bug\"
  clojure -M:cli complete --task-id 42 --comment \"Fixed\"
  clojure -M:cli update --task-id 42 --status in-progress
  clojure -M:cli delete --task-id 42")

(def list-help
  "Help text for the list command."
  "List tasks with optional filters

USAGE:
  clojure -M:cli list [options]

OPTIONS:
  --status, -s <status>         Filter by status (open, closed, in-progress, blocked, any)
                                Use 'any' to list all tasks regardless of status
  --category, -c <name>         Filter by category name
  --type, -t <type>             Filter by type (task, bug, feature, story, chore)
  --parent-id, -p <id>          Filter by parent task ID
  --task-id <id>                Filter by specific task ID
  --title-pattern, --title <pattern>  Filter by title pattern (regex or substring)
  --limit <n>                   Maximum tasks to return (default: 30)
  --unique                      Enforce 0 or 1 match (error if >1)
  --format <format>             Output format: edn, json, human (default: edn)

EXAMPLES:
  clojure -M:cli list --status open --format human
  clojure -M:cli list --status any --category simple
  clojure -M:cli list --parent-id 31 --status open")

(def show-help
  "Help text for the show command."
  "Display a single task by ID

USAGE:
  clojure -M:cli show --task-id <id> [options]

OPTIONS:
  --task-id, --id <id>  Task ID to display (required)
  --format <format>     Output format: edn, json, human (default: edn)

EXAMPLES:
  clojure -M:cli show --task-id 42
  clojure -M:cli show --id 42 --format human")

(def add-help
  "Help text for the add command."
  "Create a new task

USAGE:
  clojure -M:cli add --category <name> --title <title> [options]

OPTIONS:
  --category, -c <name>     Task category (required, e.g., simple, medium, large)
  --title, -t <title>       Task title (required)
  --description, -d <text>  Task description
  --type <type>             Task type (default: task)
                            Options: task, bug, feature, story, chore
  --parent-id, -p <id>      Parent task ID (for child tasks)
  --prepend                 Add task at beginning instead of end
  --format <format>         Output format: edn, json, human (default: edn)

EXAMPLES:
  clojure -M:cli add --category simple --title \"Fix parser bug\"
  clojure -M:cli add -c medium -t \"Add auth\" -d \"Implement JWT auth\"
  clojure -M:cli add --category simple --title \"Subtask\" --parent-id 31")

(def complete-help
  "Help text for the complete command."
  "Mark a task as complete

USAGE:
  clojure -M:cli complete (--task-id <id> | --title <pattern>) [options]

OPTIONS:
  --task-id, --id <id>          Task ID to complete
  --title, -t <pattern>         Task title pattern (alternative to task-id)
  --category, -c <name>         Task category (for verification)
  --completion-comment, --comment <text>  Optional completion comment
  --format <format>             Output format: edn, json, human (default: edn)

NOTE: At least one of --task-id or --title must be provided.

EXAMPLES:
  clojure -M:cli complete --task-id 42
  clojure -M:cli complete --title \"Fix bug\" --comment \"Fixed via PR #123\"
  clojure -M:cli complete --id 42 --category simple")

(def update-help
  "Help text for the update command."
  "Update task fields

USAGE:
  clojure -M:cli update --task-id <id> [options]

OPTIONS:
  --task-id, --id <id>      Task ID to update (required)
  --title, -t <title>       New task title
  --description, -d <text>  New task description
  --design <text>           New task design notes
  --status, -s <status>     New status (open, closed, in-progress, blocked)
  --category, -c <name>     New task category
  --type <type>             New task type (task, bug, feature, story, chore)
  --parent-id, -p <id>      New parent task ID (pass empty string to remove)
  --meta <json>             New metadata as JSON object
  --relations <json>        New relations as JSON array
  --format <format>         Output format: edn, json, human (default: edn)

EXAMPLES:
  clojure -M:cli update --task-id 42 --status in-progress
  clojure -M:cli update --id 42 --title \"New title\" --description \"New desc\"
  clojure -M:cli update --task-id 42 --meta '{\"priority\":\"high\"}'")

(def delete-help
  "Help text for the delete command."
  "Delete a task

USAGE:
  clojure -M:cli delete (--task-id <id> | --title-pattern <pattern>) [options]

OPTIONS:
  --task-id, --id <id>          Task ID to delete
  --title-pattern, --title <pattern>  Title pattern to match (alternative to task-id)
  --format <format>             Output format: edn, json, human (default: edn)

NOTE: At least one of --task-id or --title-pattern must be provided.

EXAMPLES:
  clojure -M:cli delete --task-id 42
  clojure -M:cli delete --title-pattern \"old-task\"
  clojure -M:cli delete --id 42 --format human")

;; Type Coercion Functions

(defn coerce-json-map
  "Parse JSON string to Clojure map for :meta field.

  Returns the parsed map or an error map."
  [s]
  (try
    (let [parsed (json/parse-string s keyword)]
      (if (map? parsed)
        parsed
        {:error "Expected JSON object for --meta"
         :provided s}))
    (catch Exception e
      {:error (str "Invalid JSON for --meta: " (.getMessage e))
       :provided s})))

(defn coerce-json-array
  "Parse JSON string to Clojure vector for :relations field.

  Returns the parsed vector or an error map."
  [s]
  (try
    (let [parsed (json/parse-string s keyword)]
      (if (sequential? parsed)
        (vec parsed)
        {:error "Expected JSON array for --relations"
         :provided s}))
    (catch Exception e
      {:error (str "Invalid JSON for --relations: " (.getMessage e))
       :provided s})))

(defn coerce-parent-id
  "Coerce parent-id value, handling 'null' string as nil.

  Accepts:
  - String \"null\" -> nil
  - Numeric string -> parsed long
  - Number -> long

  Returns the coerced value or throws exception on invalid input."
  [v]
  (cond
    (nil? v) nil
    (= "null" v) nil
    (string? v) (Long/parseLong v)
    (number? v) (long v)
    :else (throw (ex-info "Invalid parent-id value" {:value v}))))

(defn resolve-alias
  "Resolve an aliased key from parsed map.

  Returns the value of primary-key if present, otherwise tries alias-key.
  If both are absent, returns nil."
  [parsed-map primary-key alias-key]
  (or (get parsed-map primary-key)
      (get parsed-map alias-key)))

;; Error Handling Functions

(defn format-unknown-option-error
  "Format babashka.cli unknown option error into user-friendly message.

  Converts ':option-name' to '--option-name' and adds help suggestion."
  [cli-error-message]
  (if-let [option-match (re-find #"Unknown option: :(\S+)" cli-error-message)]
    (str "Unknown option: --" (second option-match) ". Use --help to see valid options.")
    cli-error-message))

(defn get-allowed-keys
  "Extract all allowed keys from a spec, including aliases.

  Returns a set of keywords representing all valid option keys."
  [spec]
  (reduce
    (fn [acc [k v]]
      (if-let [alias (:alias v)]
        (conj acc k alias)
        (conj acc k)))
    #{}
    spec))

;; Validation Functions

(defn validate-at-least-one
  "Validate that at least one of the specified keys is present in the parsed map.

  Returns {:valid? true} or {:valid? false :error \"...\" :details {...}}"
  [parsed-map required-keys field-names]
  (let [present-keys (filter #(contains? parsed-map %) required-keys)]
    (if (seq present-keys)
      {:valid? true}
      {:valid? false
       :error (str "At least one of " (str/join ", " field-names) " must be provided")
       :metadata {:required-one-of required-keys}})))

(defn validate-format
  "Validate that the format is one of the allowed values.

  Returns {:valid? true} or {:valid? false :error \"...\" :details {...}}"
  [parsed-map]
  (if-let [fmt (:format parsed-map)]
    (if (#{:edn :json :human} fmt)
      {:valid? true}
      {:valid? false
       :error (str "Invalid format: " (name fmt) ". Must be one of: edn, json, human")
       :metadata {:provided fmt
                  :allowed #{:edn :json :human}}})
    {:valid? true}))

(defn validate-status
  "Validate that status is one of the allowed values.

  Returns {:valid? true} or {:valid? false :error \"...\" :details {...}}"
  [parsed-map]
  (if-let [status (:status parsed-map)]
    (if (#{:open :closed :in-progress :blocked :any} status)
      {:valid? true}
      {:valid? false
       :error (str "Invalid status value '" (name status) "'. Must be one of: open, closed, in-progress, blocked, any")
       :metadata {:provided status
                  :allowed #{:open :closed :in-progress :blocked :any}}})
    {:valid? true}))

;; Command Spec Maps

(def list-spec
  "Spec for the list command.

  Validates and coerces arguments for querying tasks with filters.

  Coercion rules:
  - :status -> keyword (open, closed, in-progress, blocked, any)
  - :type -> keyword (task, bug, feature, story, chore)
  - :parent-id -> long integer
  - :task-id -> long integer
  - :limit -> long integer (default: 30)
  - :unique -> boolean
  - :format -> keyword (edn, json, human)

  Validation:
  - Post-parse validation checks format is valid (edn, json, human)"
  {:status {:coerce :keyword
            :alias :s
            :desc "Filter by status (open, closed, in-progress, blocked, any)"}
   :category {:alias :c
              :desc "Filter by category name"}
   :type {:coerce :keyword
          :alias :t
          :desc "Filter by type (task, bug, feature, story, chore)"}
   :parent-id {:coerce :long
               :alias :p
               :desc "Filter by parent task ID"}
   :task-id {:coerce :long
             :desc "Filter by specific task ID"}
   :title-pattern {:alias :title
                   :desc "Filter by title pattern (regex or substring)"}
   :limit {:coerce :long
           :default 30
           :desc "Maximum number of tasks to return"}
   :unique {:coerce :boolean
            :desc "Enforce that 0 or 1 task matches (error if >1)"}
   :format {:coerce :keyword
            :desc "Output format (edn, json, human)"}})

(def show-spec
  "Spec for the show command.

  Validates and coerces arguments for displaying a single task.

  Coercion rules:
  - :task-id -> long integer
  - :format -> keyword (edn, json, human)

  Validation:
  - Post-parse validation checks format is valid (edn, json, human)
  - Requires :task-id to be present"
  {:task-id {:coerce :long
             :alias :id
             :desc "Task ID to display"}
   :format {:coerce :keyword
            :desc "Output format (edn, json, human)"}})

(def add-spec
  "Spec for the add command.

  Validates and coerces arguments for creating new tasks.

  Coercion rules:
  - :type -> keyword (task, bug, feature, story, chore), default: :task
  - :parent-id -> long integer
  - :prepend -> boolean
  - :format -> keyword (edn, json, human)

  Validation:
  - Post-parse validation checks format is valid (edn, json, human)
  - Requires both :category and :title to be present"
  {:category {:alias :c
              :desc "Task category (e.g., simple, medium, large)"}
   :title {:alias :t
           :desc "Task title"}
   :description {:alias :d
                 :desc "Task description"}
   :type {:coerce :keyword
          :default :task
          :desc "Task type (task, bug, feature, story, chore)"}
   :parent-id {:coerce :long
               :alias :p
               :desc "Parent task ID (for child tasks)"}
   :prepend {:coerce :boolean
             :desc "Add task at beginning instead of end"}
   :format {:coerce :keyword
            :desc "Output format (edn, json, human)"}})

(def complete-spec
  "Spec for the complete command.

  Validates and coerces arguments for marking tasks complete.

  Coercion rules:
  - :task-id -> long integer
  - :format -> keyword (edn, json, human)

  Validation:
  - Post-parse validation checks format is valid (edn, json, human)
  - Requires at least one of :task-id or :title
  - Resolves :id alias to :task-id
  - Resolves :t alias to :title
  - Resolves :c alias to :category
  - Resolves :comment alias to :completion-comment"
  {:task-id {:coerce :long
             :alias :id
             :desc "Task ID to complete"}
   :title {:alias :t
           :desc "Task title (alternative to task-id)"}
   :category {:alias :c
              :desc "Task category (for verification)"}
   :completion-comment {:alias :comment
                        :desc "Optional completion comment"}
   :format {:coerce :keyword
            :desc "Output format (edn, json, human)"}})

(def update-spec
  "Spec for the update command.

  Validates and coerces arguments for updating task fields.

  Coercion rules:
  - :task-id -> long integer
  - :status -> keyword (open, closed, in-progress, blocked)
  - :type -> keyword (task, bug, feature, story, chore)
  - :parent-id -> long integer or nil (via coerce-parent-id)
  - :meta -> parsed from JSON string to Clojure map
  - :relations -> parsed from JSON array to Clojure vector
  - :format -> keyword (edn, json, human)

  Validation:
  - Post-parse validation checks format is valid (edn, json, human)
  - Requires :task-id to be present"
  {:task-id {:coerce :long
             :alias :id
             :desc "Task ID to update"}
   :title {:alias :t
           :desc "New task title"}
   :description {:alias :d
                 :desc "New task description"}
   :design {:desc "New task design notes"}
   :status {:coerce :keyword
            :alias :s
            :desc "New status (open, closed, in-progress, blocked)"}
   :category {:alias :c
              :desc "New task category"}
   :type {:coerce :keyword
          :desc "New task type (task, bug, feature, story, chore)"}
   :parent-id {:coerce coerce-parent-id
               :alias :p
               :desc "New parent task ID (or 'null' to remove)"}
   :meta {:desc "New metadata as JSON object"}
   :relations {:desc "New relations as JSON array"}
   :format {:coerce :keyword
            :desc "Output format (edn, json, human)"}})

(def delete-spec
  "Spec for the delete command.

  Validates and coerces arguments for deleting tasks.

  Coercion rules:
  - :task-id -> long integer
  - :format -> keyword (edn, json, human)

  Validation:
  - Post-parse validation checks format is valid (edn, json, human)
  - Requires at least one of :task-id or :title-pattern"
  {:task-id {:coerce :long
             :alias :id
             :desc "Task ID to delete"}
   :title-pattern {:alias :title
                   :desc "Title pattern to match (alternative to task-id)"}
   :format {:coerce :keyword
            :desc "Output format (edn, json, human)"}})

;; Parse Functions

(defn parse-list
  "Parse arguments for the list command.

  Returns parsed options map or error map with :error key."
  [args]
  (try
    (let [raw-parsed (cli/parse-opts args {:spec list-spec :restrict (get-allowed-keys list-spec)})
          parsed (-> raw-parsed
                     (dissoc :s :c :t :p :title)
                     (cond-> (:s raw-parsed) (assoc :status (:s raw-parsed)))
                     (cond-> (:c raw-parsed) (assoc :category (:c raw-parsed)))
                     (cond-> (:t raw-parsed) (assoc :type (:t raw-parsed)))
                     (cond-> (contains? raw-parsed :p) (assoc :parent-id (:p raw-parsed)))
                     (cond-> (:title raw-parsed) (assoc :title-pattern (:title raw-parsed))))
          format-validation (validate-format parsed)
          status-validation (validate-status parsed)]
      (cond
        (not (:valid? format-validation))
        (dissoc format-validation :valid?)

        (not (:valid? status-validation))
        (dissoc status-validation :valid?)

        :else
        parsed))
    (catch Exception e
      {:error (format-unknown-option-error (.getMessage e))
       :metadata {:args args}})))

(defn parse-show
  "Parse arguments for the show command.

  Returns parsed options map or error map with :error key."
  [args]
  (try
    (let [parsed (cli/parse-opts args {:spec show-spec :restrict (get-allowed-keys show-spec)})
          task-id (resolve-alias parsed :task-id :id)]
      (cond
        (not task-id)
        {:error "Required option: --task-id (or --id)"
         :metadata {:args args}}

        :else
        (let [result (-> parsed
                         (dissoc :id)
                         (assoc :task-id task-id))
              format-validation (validate-format result)]
          (if (:valid? format-validation)
            result
            (dissoc format-validation :valid?)))))
    (catch Exception e
      {:error (format-unknown-option-error (.getMessage e))
       :metadata {:args args}})))

(defn parse-add
  "Parse arguments for the add command.

  Returns parsed options map or error map with :error key."
  [args]
  (try
    (let [raw-parsed (cli/parse-opts args {:spec add-spec :restrict (get-allowed-keys add-spec)})
          category (resolve-alias raw-parsed :category :c)
          title (resolve-alias raw-parsed :title :t)
          parsed (-> raw-parsed
                     (dissoc :c :t :d :p)
                     (cond-> category (assoc :category category))
                     (cond-> title (assoc :title title))
                     (cond-> (:d raw-parsed) (assoc :description (:d raw-parsed)))
                     (cond-> (contains? raw-parsed :p) (assoc :parent-id (:p raw-parsed))))]
      (cond
        (not category)
        {:error "Required option: --category (or -c)"
         :metadata {:args args}}

        (not title)
        {:error "Required option: --title (or -t)"
         :metadata {:args args}}

        :else
        (let [format-validation (validate-format parsed)]
          (if (:valid? format-validation)
            parsed
            (dissoc format-validation :valid?)))))
    (catch Exception e
      {:error (format-unknown-option-error (.getMessage e))
       :metadata {:args args}})))

(defn parse-complete
  "Parse arguments for the complete command.

  Validates that at least one of task-id or title is provided.
  Returns parsed options map or error map with :error key."
  [args]
  (try
    (let [raw-parsed (cli/parse-opts args {:spec complete-spec :restrict (get-allowed-keys complete-spec)})
          task-id (or (:task-id raw-parsed) (:id raw-parsed))
          parsed (-> raw-parsed
                     (dissoc :id :t :c :comment)
                     (cond-> task-id (assoc :task-id task-id))
                     (cond-> (:t raw-parsed) (assoc :title (:t raw-parsed)))
                     (cond-> (:c raw-parsed) (assoc :category (:c raw-parsed)))
                     (cond-> (:comment raw-parsed) (assoc :completion-comment (:comment raw-parsed))))
          at-least-one-validation (validate-at-least-one parsed [:task-id :title] ["--task-id" "--title"])]
      (if-not (:valid? at-least-one-validation)
        (dissoc at-least-one-validation :valid?)
        (let [format-validation (validate-format parsed)]
          (if (:valid? format-validation)
            parsed
            (dissoc format-validation :valid?)))))
    (catch Exception e
      {:error (format-unknown-option-error (.getMessage e))
       :metadata {:args args}})))

(defn parse-update
  "Parse arguments for the update command.

  Handles JSON parsing for :meta and :relations fields.
  Returns parsed options map or error map with :error key."
  [args]
  (try
    (let [raw-parsed (cli/parse-opts args {:spec update-spec :restrict (get-allowed-keys update-spec)})
          task-id (or (:task-id raw-parsed) (:id raw-parsed))
          parsed (-> raw-parsed
                     (dissoc :id :t :d :s :c :p)
                     (cond-> task-id (assoc :task-id task-id))
                     (cond-> (:t raw-parsed) (assoc :title (:t raw-parsed)))
                     (cond-> (:d raw-parsed) (assoc :description (:d raw-parsed)))
                     (cond-> (:s raw-parsed) (assoc :status (:s raw-parsed)))
                     (cond-> (:c raw-parsed) (assoc :category (:c raw-parsed)))
                     (cond-> (contains? raw-parsed :p) (assoc :parent-id (:p raw-parsed))))]
      (if-not task-id
        {:error "Required option: --task-id (or --id)"
         :metadata {:args args}}
        ;; Parse :meta if provided
        (if-let [meta-str (:meta parsed)]
          (let [meta-result (coerce-json-map meta-str)]
            (if (:error meta-result)
              meta-result
              (let [parsed-with-meta (assoc parsed :meta meta-result)]
                ;; Parse :relations if provided
                (if-let [relations-str (:relations parsed-with-meta)]
                  (let [relations-result (coerce-json-array relations-str)]
                    (if (:error relations-result)
                      relations-result
                      (let [final-parsed (assoc parsed-with-meta :relations relations-result)
                            format-validation (validate-format final-parsed)]
                        (if (:valid? format-validation)
                          final-parsed
                          (dissoc format-validation :valid?)))))
                  (let [format-validation (validate-format parsed-with-meta)]
                    (if (:valid? format-validation)
                      parsed-with-meta
                      (dissoc format-validation :valid?)))))))
          ;; No :meta, check :relations
          (if-let [relations-str (:relations parsed)]
            (let [relations-result (coerce-json-array relations-str)]
              (if (:error relations-result)
                relations-result
                (let [final-parsed (assoc parsed :relations relations-result)
                      format-validation (validate-format final-parsed)]
                  (if (:valid? format-validation)
                    final-parsed
                    (dissoc format-validation :valid?)))))
            (let [format-validation (validate-format parsed)]
              (if (:valid? format-validation)
                parsed
                (dissoc format-validation :valid?)))))))
    (catch Exception e
      {:error (format-unknown-option-error (.getMessage e))
       :metadata {:args args}})))

(defn parse-delete
  "Parse arguments for the delete command.

  Validates that at least one of task-id or title-pattern is provided.
  Returns parsed options map or error map with :error key."
  [args]
  (try
    (let [raw-parsed (cli/parse-opts args {:spec delete-spec :restrict (get-allowed-keys delete-spec)})
          task-id (or (:task-id raw-parsed) (:id raw-parsed))
          parsed (-> raw-parsed
                     (dissoc :id :title)
                     (cond-> task-id (assoc :task-id task-id))
                     (cond-> (:title raw-parsed) (assoc :title-pattern (:title raw-parsed))))
          at-least-one-validation (validate-at-least-one parsed [:task-id :title-pattern] ["--task-id" "--title-pattern"])]
      (if-not (:valid? at-least-one-validation)
        (dissoc at-least-one-validation :valid?)
        (let [format-validation (validate-format parsed)]
          (if (:valid? format-validation)
            parsed
            (dissoc format-validation :valid?)))))
    (catch Exception e
      {:error (format-unknown-option-error (.getMessage e))
       :metadata {:args args}})))
(ns mcp-tasks.cli.format
  "Output formatters for the CLI.

  Supports EDN, JSON, and human-readable formats."
  (:require
    [cheshire.core :as json]
    [clojure.string :as str]))

;; Key transformation

(defn kebab->camel
  "Convert a kebab-case keyword to camelCase string.

  Examples:
    :task-id => \"taskId\"
    :parent-id => \"parentId\"
    :status => \"status\""
  [k]
  (let [s (name k)
        parts (str/split s #"-")]
    (if (= 1 (count parts))
      s
      (str (first parts)
           (str/join (map str/capitalize (rest parts)))))))

(defn transform-keys
  "Recursively transform all keys in a map using the provided function.

  Handles nested maps, vectors of maps, and preserves other data types."
  [m key-fn]
  (cond
    (map? m)
    (into {} (map (fn [[k v]]
                    [(key-fn k) (transform-keys v key-fn)])
                  m))

    (vector? m)
    (mapv #(transform-keys % key-fn) m)

    :else
    m))

;; Text formatting helpers

(defn truncate-text
  "Truncate text to max-length characters, adding ellipsis if truncated."
  [text max-length]
  (let [text (or text "")]
    (if (<= (count text) max-length)
      text
      (str (subs text 0 (- max-length 3)) "..."))))

(defn format-relations
  "Format relations vector to human-readable string.

  Examples:
    [{:as-type :blocked-by :relates-to 4}] => \"blocked-by->#4\"
    [{:as-type :related :relates-to 5} {:as-type :blocked-by :relates-to 6}]
      => \"related->#5, blocked-by->#6\""
  [relations]
  (when (seq relations)
    (str/join ", "
              (map (fn [{:keys [as-type relates-to]}]
                     (str (name as-type) "->#" relates-to))
                   relations))))

(defn format-status
  "Format status with visual indicator."
  [status]
  (case status
    :open "○ open"
    :closed "✓ closed"
    :in-progress "◐ in-progress"
    :blocked "✗ blocked"
    :deleted "⊗ deleted"
    nil "○ open"
    (name status)))

(defn format-meta
  "Format meta map for table display.

  Returns a string representation, using '-' for empty meta."
  [meta]
  (if (seq meta)
    (pr-str meta)
    "-"))

;; Table formatting

(defn format-table-row
  "Format a single row of the table with proper column widths."
  [id parent-id status category meta title max-title-width]
  (format "%4s  %-8s  %-12s  %-10s  %-20s  %s"
          (or id "")
          (if parent-id (str parent-id) "")
          (truncate-text status 12)
          (truncate-text category 10)
          (truncate-text meta 20)
          (truncate-text title max-title-width)))

(defn format-table
  "Format a vector of tasks as an ASCII table.

  Columns: ID, Parent, Status, Category, Meta, Title (truncated)"
  [tasks]
  (if (empty? tasks)
    "No tasks found"
    (let [max-title-width 50
          header (format "%4s  %-8s  %-12s  %-10s  %-20s  %s" "ID" "Parent" "Status" "Category" "Meta" "Title")
          separator (str/join (repeat (+ 4 2 8 2 12 2 10 2 20 2 max-title-width) "-"))
          rows (map (fn [task]
                      (format-table-row
                        (:id task)
                        (:parent-id task)
                        (format-status (:status task))
                        (:category task)
                        (format-meta (:meta task))
                        (:title task)
                        max-title-width))
                    tasks)]
      (str/join "\n" (concat [header separator] rows)))))

;; Single task formatting

(defn format-single-task
  "Format a single task with all details in multi-line format."
  [task]
  (let [lines [(str "Task #" (or (:id task) "?") ": " (or (:title task) "Untitled"))
               (str "Status: " (name (or (:status task) :open)))
               (str "Category: " (or (:category task) "unknown"))
               (str "Type: " (name (or (:type task) :task)))]]
    (str/join "\n"
              (cond-> lines
                ;; Add parent-id if present
                (:parent-id task)
                (conj (str "Parent: #" (:parent-id task)))

                ;; Add relations if present
                (seq (:relations task))
                (conj (str "Relations: " (format-relations (:relations task))))

                ;; Add metadata if present
                (seq (:meta task))
                (conj (str "Meta: " (pr-str (:meta task))))

                ;; Add description if non-empty
                (and (:description task) (not (str/blank? (:description task))))
                (conj "Description:"
                      (str "  " (str/replace (:description task) #"\n" "\n  ")))

                ;; Add design if non-empty
                (and (:design task) (not (str/blank? (:design task))))
                (conj "Design:"
                      (str "  " (str/replace (:design task) #"\n" "\n  ")))))))

;; Error formatting

(defn format-error
  "Format error response for human-readable output."
  [data]
  (let [error-msg (:error data)
        metadata (:metadata data)]
    (str "Error: " error-msg "\n"
         (when (seq metadata)
           (str/join "\n"
                     (map (fn [[k v]]
                            (str "  " (name k) ": " v))
                          metadata))))))

;; Git metadata formatting

(defn format-git-metadata
  "Format git metadata (commit SHA, status, errors)."
  [git-data]
  (when git-data
    (let [status (:git-status git-data)
          sha (:git-commit git-data)
          error (:git-error git-data)
          lines (cond-> []
                  status
                  (conj (str "Git Status: " status))

                  sha
                  (conj (str "Commit: " sha))

                  error
                  (conj (str "Git Error: " error)))]
      (when (seq lines)
        (str/join "\n" lines)))))

;; Multimethod for format dispatch

(defmulti render
  "Render data in the specified format.

  Dispatches on format-type (:edn, :json, or :human).
  Returns formatted string output."
  (fn [format-type _data] format-type))

(defmethod render :edn
  [_ data]
  (pr-str data))

(defmethod render :json
  [_ data]
  (json/generate-string (transform-keys data kebab->camel)))

(defmethod render :human
  [_ data]
  (cond
    ;; Error response
    (:error data)
    (format-error data)

    ;; Response with tasks
    (:tasks data)
    (let [tasks (:tasks data)
          metadata (:metadata data)
          task-count (count tasks)
          task-output (format-table tasks)
          git-output (format-git-metadata data)]
      (str/join "\n\n"
                (filter some?
                        [task-output
                         git-output
                         ;; Only show metadata if there are tasks
                         (when (and metadata (pos? task-count))
                           (str "Total: " (:total-matches metadata)
                                (when (:limited? metadata)
                                  (str " (showing " (:returned-count metadata) ")"))))])))

    ;; Single task response (for add/update/complete operations)
    (:task data)
    (let [task (:task data)
          metadata (:metadata data)
          operation (:operation metadata)
          ;; Add operation-specific success message
          success-msg (case operation
                        "complete-task" (str "Task #" (:id task) " completed")
                        "add-task" (str "Added task #" (:id task))
                        "update-task" (str "Updated task #" (:id task))
                        nil)
          task-output (format-single-task task)
          git-output (format-git-metadata data)]
      (str/join "\n\n"
                (filter some?
                        [success-msg
                         task-output
                         (when metadata
                           (str "File: " (:file metadata)))
                         git-output])))

    ;; Deleted task response
    (:deleted data)
    (let [task (:deleted data)
          task-output (str "Deleted Task #" (:id task) ": " (:title task))
          git-output (format-git-metadata data)]
      (str/join "\n\n" (filter some? [task-output git-output])))

    ;; Generic response with modified files
    (:modified-files data)
    (str "Modified files:\n"
         (str/join "\n" (map #(str "  " %) (:modified-files data))))

    ;; Git status only
    (:git-status data)
    (format-git-metadata data)

    ;; Fallback: just pr-str
    :else
    (pr-str data)))

(defmethod render :default
  [format-type _data]
  (throw (ex-info (str "Unknown format type: " format-type)
                  {:format-type format-type
                   :valid-formats [:edn :json :human]})))
(ns mcp-tasks.cli.commands
  "Command implementations for the CLI.
  
  Thin wrappers around mcp-tasks.tools functions.
  
  Uses lazy-loading via requiring-resolve to only load the tool namespaces
  that are actually used, improving startup time for simple commands."
  (:require
    [cheshire.core :as json]))

(defn- parse-tool-response
  "Parse JSON response from tool *-impl functions.
  
  Different tools return different numbers of content items:
  - select-tasks: 1 content item with JSON
  - add-task/update-task/complete-task/delete-task:
    - Without git: 2 content items (message + JSON with task data)
    - With git: 3 content items (message + JSON with task data + JSON with git status)
  - errors: 2 content items (message + JSON with :error key)
  
  This function parses all JSON content items and merges them into a single map.
  Returns the parsed data map (including error responses)."
  [response]
  (let [content-items (:content response)
        ;; Parse all JSON content items and merge them
        json-items (keep (fn [item]
                           (when-let [text (:text item)]
                             (try
                               (json/parse-string text keyword)
                               (catch Exception _ nil))))
                         content-items)]
    ;; Merge all parsed JSON maps, with later items taking precedence
    (apply merge {} json-items)))

(def ^:private tool-map
  "Map of command names to their tool function symbols.
  
  Uses symbols instead of direct references to enable lazy loading via requiring-resolve."
  {:list 'mcp-tasks.tool.select-tasks/select-tasks-tool
   :show 'mcp-tasks.tool.select-tasks/select-tasks-tool
   :add 'mcp-tasks.tool.add-task/add-task-tool
   :complete 'mcp-tasks.tool.complete-task/complete-task-tool
   :update 'mcp-tasks.tool.update-task/update-task-tool
   :delete 'mcp-tasks.tool.delete-task/delete-task-tool})

(defn- execute-command
  "Execute a command by calling its corresponding tool implementation.
  
  Uses requiring-resolve to lazily load only the tool namespace needed for this command.
  
  Parameters:
  - config: The loaded configuration map
  - command-key: Keyword identifying the command (:list, :show, etc.)
  - parsed-args: Parsed command-line arguments
  - arg-transform-fn: Optional function to transform args before passing to tool (default identity)
  
  Returns the parsed response data from the tool."
  ([config command-key parsed-args]
   (execute-command config command-key parsed-args identity))
  ([config command-key parsed-args arg-transform-fn]
   (let [tool-args (-> parsed-args
                       (dissoc :format)
                       arg-transform-fn)
         tool-fn-sym (get tool-map command-key)
         tool-fn (requiring-resolve tool-fn-sym)
         tool (tool-fn config)
         impl-fn (:implementation tool)
         response (impl-fn nil tool-args)]
     (parse-tool-response response))))

(defn list-command
  "Execute the list command.
  
  Calls tools/select-tasks-tool implementation and returns the parsed response data."
  [config parsed-args]
  (execute-command config :list parsed-args))

(defn show-command
  "Execute the show command.
  
  Calls tools/select-tasks-tool with unique: true and transforms the response
  to use :task (singular) instead of :tasks to trigger detailed format."
  [config parsed-args]
  (let [response (execute-command config :show parsed-args #(assoc % :unique true))
        ;; Transform {:tasks [...]} to {:task ...} for detailed format
        tasks (:tasks response)]
    (if (seq tasks)
      (-> response
          (assoc :task (first tasks))
          (dissoc :tasks))
      response)))

(defn add-command
  "Execute the add command.
  
  Calls tools/add-task-tool and returns the parsed response data."
  [config parsed-args]
  (execute-command config :add parsed-args))

(defn complete-command
  "Execute the complete command.
  
  Calls tools/complete-task-tool and returns the parsed response data."
  [config parsed-args]
  (execute-command config :complete parsed-args))

(defn update-command
  "Execute the update command.
  
  Calls tools/update-task-tool and returns the parsed response data."
  [config parsed-args]
  (execute-command config :update parsed-args))

(defn delete-command
  "Execute the delete command.
  
  Calls tools/delete-task-tool and returns the parsed response data."
  [config parsed-args]
  (execute-command config :delete parsed-args))
(ns mcp-tasks.cli
  "Command-line interface for mcp-tasks.
  
  Entry point for the CLI that routes commands to their implementations."
  (:require
    [babashka.cli :as cli]
    [clojure.string :as str]
    [mcp-tasks.cli.commands :as commands]
    [mcp-tasks.cli.format :as format]
    [mcp-tasks.cli.parse :as parse]
    [mcp-tasks.config :as config]))

(defn exit
  "Exit the program with the given status code.
  Extracted as a separate function to allow testing without actually exiting."
  [code]
  (System/exit code))

(defn -main
  "Main entry point for the CLI."
  [& args]
  (try
    (let [;; Find the first argument that looks like a command (not an option or option value)
          ;; Valid commands are known strings that don't start with --
          valid-commands #{"list" "show" "add" "complete" "update" "delete"}
          ;; Find command by looking for first valid command OR first non-option after options
          command-idx (loop [idx 0
                             prev-was-option? false]
                        (if (>= idx (count args))
                          idx
                          (let [arg (nth args idx)]
                            (cond
                              ;; Found a valid command
                              (valid-commands arg) idx
                              ;; This is an option flag, skip it and mark that next might be its value
                              (str/starts-with? arg "--") (recur (inc idx) true)
                              ;; Previous was option, this is its value, skip it
                              prev-was-option? (recur (inc idx) false)
                              ;; Not an option and not preceded by option flag - must be command
                              :else idx))))
          global-args (take command-idx args)
          command-and-args (drop command-idx args)

          ;; Parse only global args that appear before the command
          parsed (cli/parse-args global-args {:coerce {:format :keyword}})
          {:keys [format help]} (:opts parsed)
          format (or format :human)
          command (first command-and-args)
          command-args (rest command-and-args)]

      ;; Handle global help or no command
      (cond
        (or help (nil? command))
        (do
          (println parse/help-text)
          (exit 0))

        ;; Handle command-specific help
        (and (= "--help" (first command-args))
             (contains? #{"list" "show" "add" "complete" "update" "delete"} command))
        (do
          (case command
            "list" (println parse/list-help)
            "show" (println parse/show-help)
            "add" (println parse/add-help)
            "complete" (println parse/complete-help)
            "update" (println parse/update-help)
            "delete" (println parse/delete-help))
          (exit 0))

        ;; Execute command
        :else
        (let [valid-commands #{"list" "show" "add" "complete" "update" "delete"}]
          ;; Validate command is known
          (if-not (contains? valid-commands command)
            (do
              (binding [*out* *err*]
                (println (str "Unknown command: " command))
                (println)
                (println parse/help-text))
              (exit 1))

            ;; Load config using automatic discovery
            (let [{:keys [raw-config config-dir]} (config/read-config)
                  resolved-config (config/resolve-config config-dir raw-config)
                  _ (config/validate-startup config-dir resolved-config)

                  ;; Parse command-specific args
                  parsed-args (case command
                                "list" (parse/parse-list command-args)
                                "show" (parse/parse-show command-args)
                                "add" (parse/parse-add command-args)
                                "complete" (parse/parse-complete command-args)
                                "update" (parse/parse-update command-args)
                                "delete" (parse/parse-delete command-args))]

              ;; Check for parsing errors
              (if (:error parsed-args)
                (do
                  (binding [*out* *err*]
                    (println (format/format-error parsed-args)))
                  (exit 1))

                ;; Execute command
                (let [result (case command
                               "list" (commands/list-command resolved-config parsed-args)
                               "show" (commands/show-command resolved-config parsed-args)
                               "add" (commands/add-command resolved-config parsed-args)
                               "complete" (commands/complete-command resolved-config parsed-args)
                               "update" (commands/update-command resolved-config parsed-args)
                               "delete" (commands/delete-command resolved-config parsed-args))
                      output-format (or (:format parsed-args) format)
                      formatted-output (format/render output-format result)]
                  (if (:error result)
                    (do
                      (binding [*out* *err*]
                        (println formatted-output))
                      (exit 1))
                    (do
                      (println formatted-output)
                      (exit 0))))))))))

    (catch clojure.lang.ExceptionInfo e
      (let [data (ex-data e)]
        (binding [*out* *err*]
          (if (= :tool-error (:type data))
            (println (.getMessage e))
            (println (format/format-error {:error (.getMessage e)
                                           :details data}))))
        (exit 1)))

    (catch Exception e
      (binding [*out* *err*]
        (println (format/format-error {:error (.getMessage e)})))
      (exit 1))))
(ns mcp-tasks.util
  "Utility functions for mcp-tasks."
  (:require
    [clojure.string :as str]))

(defn sanitize-branch-name
  "Sanitize a title into a valid git branch name with task ID prefix.
  
  The title is processed by:
  1. Handling empty/blank titles (returns \"task-<id>\")
  2. Splitting into words and taking first `word-limit` words (all if nil)
  3. Joining words with spaces
  4. Converting to lowercase
  5. Replacing spaces with dashes
  6. Removing all special characters (keeping only a-z, 0-9, -)
  7. Replacing multiple consecutive dashes with single dash
  8. Trimming leading/trailing dashes
  9. Prepending task ID: \"<id>-<slug>\"
  10. Truncating to 200 characters if longer
  
  Returns \"task-<id>\" if title is empty or becomes empty after slugification.
  
  Parameters:
  - title: The title string to sanitize
  - task-id: The task ID number (used as prefix)
  - word-limit: Maximum number of words to use from title (nil = unlimited)
  
  Examples:
  (sanitize-branch-name \"Implement user authentication with OAuth support\" 123 4)
  => \"123-implement-user-authentication-with\"
  
  (sanitize-branch-name \"Implement user authentication\" 123 2)
  => \"123-implement-user\"
  
  (sanitize-branch-name \"Fix bug #456\" 10 nil)
  => \"10-fix-bug-456\"
  
  (sanitize-branch-name \"!!!\" 45 4)
  => \"task-45\"
  
  (sanitize-branch-name \"ui\" 5 4)
  => \"5-ui\""
  [title task-id word-limit]
  ;; Handle empty/blank title edge case
  (if (str/blank? title)
    (str "task-" task-id)
    (let [;; Split into words
          words (str/split (str/trim title) #"\s+")
          ;; Take first N words (or all if limit is nil or exceeds available)
          limited-words (if (or (nil? word-limit)
                                (>= word-limit (count words)))
                          words
                          (take word-limit words))
          ;; Join with spaces
          limited-title (str/join " " limited-words)
          ;; Slugify: lowercase, spaces to dashes, remove special chars
          slug (-> limited-title
                   str/lower-case
                   (str/replace #"\s+" "-")
                   (str/replace #"[^a-z0-9-]" "")
                   (str/replace #"-+" "-")
                   (str/replace #"^-+" "")
                   (str/replace #"-+$" ""))
          ;; Prepend ID
          with-id (if (str/blank? slug)
                    (str "task-" task-id)
                    (str task-id "-" slug))]
      ;; Truncate if needed
      (if (> (count with-id) 200)
        (subs with-id 0 200)
        with-id))))
(ns mcp-tasks.tools.git
  "Git-related helper functions for task management.

  ## Directory Parameters

  Functions in this namespace accept directory parameters that determine where
  git operations are executed. Understanding the difference is crucial when
  working with git worktrees.

  ### Main Repository Directory (:main-repo-dir)

  Use for repository-wide operations that must run from the main repository:
  - list-worktrees - Lists all worktrees in the repository
  - find-worktree-for-branch - Searches for a branch across all worktrees
  - worktree-exists? - Checks if a worktree path exists
  - create-worktree - Creates a new worktree
  - remove-worktree - Removes a worktree
  - derive-worktree-path - Derives the path for a new worktree
  - derive-project-name - Gets the project name from main repository

  ### Base Directory (:base-dir)

  Use for context-specific operations in the current working directory:
  - get-current-branch - Gets the branch in current directory
  - check-uncommitted-changes - Checks changes in current directory
  - check-all-pushed? - Checks if all commits are pushed to remote
  - branch-exists? - Checks if a branch exists (works from any directory)
  - checkout-branch - Checks out a branch in current directory
  - create-and-checkout-branch - Creates and checks out branch in current directory
  - pull-latest - Pulls latest changes in current directory
  - get-default-branch - Gets default branch (works from any directory)
  - commit-task-changes - Commits changes in current directory

  ### Worktree-Specific

  - worktree-branch - Uses provided worktree path parameter (not base-dir)"
  (:require
    [babashka.fs :as fs]
    [clojure.java.shell :as sh]
    [clojure.string :as str]
    [mcp-tasks.util :as util]))

;; Worktree Detection

(defn in-worktree?
  "Returns true if dir is a git worktree (not the main repository).
  
  In a worktree, .git is a file pointing to the main repo's worktree metadata.
  In the main repo, .git is a directory containing the actual git database.
  
  Parameters:
  - dir: Path to check (string or File)
  
  Returns:
  - true if dir is a worktree
  - false if dir is a main repository or not a git directory"
  [dir]
  (let [git-file (fs/file dir ".git")]
    (and (fs/exists? git-file)
         (fs/regular-file? git-file))))

(defn find-main-repo
  "Extracts the main repository path from a worktree's .git file.
  
  The .git file in a worktree contains a line like:
  gitdir: /path/to/main/.git/worktrees/name
  
  This function parses that line and resolves to the main repo root.
  
  Parameters:
  - worktree-dir: Path to the worktree directory
  
  Returns the absolute path to the main repository root directory."
  [worktree-dir]
  {:pre [(in-worktree? worktree-dir)]}
  (let [git-file (fs/file worktree-dir ".git")
        content (slurp git-file)
        ;; Extract the gitdir path from "gitdir: /path/to/.git/worktrees/name"
        gitdir-match (re-find #"gitdir:\s*(.+)" content)]
    (when-not gitdir-match
      (throw (ex-info "Invalid .git file format in worktree"
                      {:worktree-dir worktree-dir
                       :content content})))
    (let [gitdir-path (second gitdir-match)
          ;; The gitdir points to .git/worktrees/name
          ;; We need to go up to .git, then up to the main repo root
          main-git-dir (-> gitdir-path
                           fs/file
                           fs/parent ; Go from .git/worktrees/name to .git/worktrees
                           fs/parent) ; Go from .git/worktrees to .git
          main-repo-dir (fs/parent main-git-dir)]
      (str (fs/canonicalize main-repo-dir)))))

(defn get-main-repo-dir
  "Returns the main repository directory for the given path.
  
  If the path is a worktree, returns the main repository path.
  If the path is already the main repository, returns it unchanged.
  
  Parameters:
  - dir: Path to check (can be worktree or main repo)
  
  Returns the absolute path to the main repository root directory."
  [dir]
  (if (in-worktree? dir)
    (find-main-repo dir)
    (str (fs/canonicalize dir))))

(defn ensure-git-success!
  "Throws ex-info if git operation failed. Returns result on success.

  Parameters:
  - result: Map with :success and :error keys from a git operation
  - operation: String describing the operation for error context

  Returns the result map unchanged if successful.
  Throws ex-info with operation details if failed."
  [result operation]
  (when-not (:success result)
    (throw (ex-info (str "Git operation failed: " operation)
                    {:error (:error result)
                     :operation operation})))
  result)

(defn perform-git-commit
  "Performs git add and commit operations.

  Parameters:
  - git-dir: Path to the git repository
  - files-to-commit: Collection of relative file paths to add and commit
  - commit-msg: The commit message string

  Returns a map with:
  - :success - boolean indicating if commit succeeded
  - :commit-sha - commit SHA string (or nil if failed)
  - :error - error message string (or nil if successful)

  Never throws - all errors are caught and returned in the map."
  [git-dir files-to-commit commit-msg]
  (try
    ;; Stage modified files
    (apply sh/sh "git" "-C" git-dir "add" files-to-commit)

    ;; Commit changes
    (let [commit-result (sh/sh "git" "-C" git-dir "commit" "-m" commit-msg)]
      (if (zero? (:exit commit-result))
        ;; Success - get commit SHA
        (let [sha-result (sh/sh "git" "-C" git-dir "rev-parse" "HEAD")
              sha (str/trim (:out sha-result))]
          {:success true
           :commit-sha sha
           :error nil})

        ;; Commit failed
        {:success false
         :commit-sha nil
         :error (str/trim (:err commit-result))}))

    (catch Exception e
      {:success false
       :commit-sha nil
       :error (.getMessage e)})))

(defn commit-task-changes
  "Commits task file changes to .mcp-tasks git repository.

  Parameters:
  - base-dir: Base directory containing .mcp-tasks
  - files-to-commit: Collection of relative file paths to add and commit
  - commit-msg: The commit message string

  Returns a map with:
  - :success - boolean indicating if commit succeeded
  - :commit-sha - commit SHA string (or nil if failed)
  - :error - error message string (or nil if successful)

  Never throws - all errors are caught and returned in the map."
  [base-dir files-to-commit commit-msg]
  (let [git-dir (str base-dir "/.mcp-tasks")]
    (perform-git-commit git-dir files-to-commit commit-msg)))

(defn get-current-branch
  "Returns the current git branch name.

  Parameters:
  - base-dir: Base directory of the git repository

  Returns a map with:
  - :success - boolean indicating if operation succeeded
  - :branch - branch name string (or nil if failed)
  - :error - error message string (or nil if successful)"
  [base-dir]
  {:pre [(string? base-dir)
         (not (clojure.string/blank? base-dir))]}
  (try
    (let [result (sh/sh "git" "-C" base-dir "rev-parse" "--abbrev-ref" "HEAD")]
      (if (zero? (:exit result))
        {:success true
         :branch (str/trim (:out result))
         :error nil}
        {:success false
         :branch nil
         :error (str/trim (:err result))}))
    (catch Exception e
      {:success false
       :branch nil
       :error (.getMessage e)})))

(defn get-default-branch
  "Returns the default branch name.

  First attempts to read from git config (origin/HEAD).
  Falls back to 'main', then 'master' if no remote is configured.

  Parameters:
  - base-dir: Base directory of the git repository

  Returns a map with:
  - :success - boolean indicating if operation succeeded
  - :branch - branch name string (or nil if failed)
  - :error - error message string (or nil if successful)"
  [base-dir]
  {:pre [(string? base-dir)
         (not (clojure.string/blank? base-dir))]}
  (try
    ;; Try to get remote default branch
    (let [result (sh/sh "git" "-C" base-dir "symbolic-ref" "refs/remotes/origin/HEAD" "--short")]
      (if (zero? (:exit result))
        ;; Remote exists, extract branch name (strip "origin/" prefix)
        (let [full-ref (str/trim (:out result))
              branch (str/replace full-ref #"^origin/" "")]
          {:success true
           :branch branch
           :error nil})
        ;; No remote, fall back to common defaults
        (let [main-result (sh/sh "git" "-C" base-dir "rev-parse" "--verify" "main")]
          (if (zero? (:exit main-result))
            {:success true
             :branch "main"
             :error nil}
            (let [master-result (sh/sh "git" "-C" base-dir "rev-parse" "--verify" "master")]
              (if (zero? (:exit master-result))
                {:success true
                 :branch "master"
                 :error nil}
                {:success false
                 :branch nil
                 :error "Could not determine default branch"}))))))
    (catch Exception e
      {:success false
       :branch nil
       :error (.getMessage e)})))

(defn check-uncommitted-changes
  "Checks if there are uncommitted changes in the working directory.

  Parameters:
  - base-dir: Base directory of the git repository

  Returns a map with:
  - :success - boolean indicating if check succeeded
  - :has-changes? - boolean indicating if uncommitted changes exist
  - :error - error message string (or nil if successful)"
  [base-dir]
  {:pre [(string? base-dir)
         (not (clojure.string/blank? base-dir))]}
  (try
    (let [result (sh/sh "git" "-C" base-dir "status" "--porcelain")]
      (if (zero? (:exit result))
        {:success true
         :has-changes? (not (str/blank? (str/trim (:out result))))
         :error nil}
        {:success false
         :has-changes? nil
         :error (str/trim (:err result))}))
    (catch Exception e
      {:success false
       :has-changes? nil
       :error (.getMessage e)})))

(defn check-all-pushed?
  "Checks if all commits in the current branch are pushed to remote.

  Uses git rev-list to compare local HEAD with remote tracking branch.
  This ensures no local work will be lost if the worktree is removed.

  Parameters:
  - base-dir: Base directory of the git repository

  Returns a map with:
  - :success - boolean indicating if check succeeded
  - :all-pushed? - boolean indicating if all commits are pushed (or nil if check failed)
  - :reason - descriptive string explaining the result"
  [base-dir]
  {:pre [(string? base-dir)
         (not (clojure.string/blank? base-dir))]}
  (try
    ;; First check if there's a tracking branch configured
    (let [tracking-check (sh/sh "git" "-C" base-dir "rev-parse" "--abbrev-ref" "@{u}")]
      (if (zero? (:exit tracking-check))
        ;; Has tracking branch - check for unpushed commits
        (let [result (sh/sh "git" "-C" base-dir "rev-list" "@{u}..HEAD")]
          (if (zero? (:exit result))
            (let [unpushed-commits (str/trim (:out result))]
              (if (str/blank? unpushed-commits)
                {:success true
                 :all-pushed? true
                 :reason "All commits are pushed to remote"}
                {:success true
                 :all-pushed? false
                 :reason "Unpushed commits exist"}))
            {:success false
             :all-pushed? nil
             :reason (str "Failed to check commits: " (str/trim (:err result)))}))
        ;; No tracking branch configured
        (let [stderr (str/trim (:err tracking-check))]
          (if (str/includes? stderr "no upstream configured")
            {:success true
             :all-pushed? false
             :reason "No remote tracking branch configured"}
            {:success false
             :all-pushed? nil
             :reason (str "Failed to check tracking branch: " stderr)}))))
    (catch Exception e
      {:success false
       :all-pushed? nil
       :reason (str "Exception checking pushed status: " (.getMessage e))})))

(defn branch-exists?
  "Checks if a branch exists.

  Parameters:
  - base-dir: Base directory of the git repository
  - branch-name: Name of the branch to check

  Returns a map with:
  - :success - boolean indicating if check succeeded
  - :exists? - boolean indicating if branch exists
  - :error - error message string (or nil if successful)"
  [base-dir branch-name]
  {:pre [(some? base-dir)
         (string? branch-name)
         (not (str/blank? branch-name))]}
  (try
    (let [result (sh/sh "git" "-C" base-dir "rev-parse" "--verify" branch-name)]
      {:success true
       :exists? (zero? (:exit result))
       :error nil})
    (catch Exception e
      {:success false
       :exists? nil
       :error (ex-message e)})))

(defn checkout-branch
  "Checks out an existing branch.

  Parameters:
  - base-dir: Base directory of the git repository
  - branch-name: Name of the branch to checkout

  Returns a map with:
  - :success - boolean indicating if checkout succeeded
  - :error - error message string (or nil if successful)"
  [base-dir branch-name]
  {:pre [(string? base-dir)
         (not (clojure.string/blank? base-dir))
         (string? branch-name)
         (not (clojure.string/blank? branch-name))]}
  (try
    (let [result (sh/sh "git" "-C" base-dir "checkout" branch-name)]
      (if (zero? (:exit result))
        {:success true
         :error nil}
        {:success false
         :error (str/trim (:err result))}))
    (catch Exception e
      {:success false
       :error (.getMessage e)})))

(defn create-and-checkout-branch
  "Creates and checks out a new branch.

  Parameters:
  - base-dir: Base directory of the git repository
  - branch-name: Name of the branch to create

  Returns a map with:
  - :success - boolean indicating if operation succeeded
  - :error - error message string (or nil if successful)"
  [base-dir branch-name]
  {:pre [(string? base-dir)
         (not (clojure.string/blank? base-dir))
         (string? branch-name)
         (not (clojure.string/blank? branch-name))]}
  (try
    (let [result (sh/sh "git" "-C" base-dir "checkout" "-b" branch-name)]
      (if (zero? (:exit result))
        {:success true
         :error nil}
        {:success false
         :error (str/trim (:err result))}))
    (catch Exception e
      {:success false
       :error (.getMessage e)})))

(defn- conflict-pattern?
  "Returns true if stderr contains conflict indicators"
  [stderr]
  (or (str/includes? stderr "CONFLICT")
      (str/includes? stderr "Automatic merge failed")
      (str/includes? stderr "fix conflicts")
      (str/includes? stderr "unresolved conflict")
      (str/includes? stderr "unmerged files")
      ;; Git 2.51+ returns this for divergent branches before attempting merge
      (str/includes? stderr "Not possible to fast-forward")
      ;; Rebase conflict patterns
      (str/includes? stderr "could not apply")
      (str/includes? stderr "Resolve all conflicts manually")))

(defn- no-remote-pattern?
  "Returns true if stderr indicates no remote is configured"
  [stderr]
  (or (str/includes? stderr "does not appear to be a git repository")
      (str/includes? stderr "No configured push destination")
      (str/includes? stderr "No remote repository specified")
      (re-find #"repository '.*' not found" stderr)))

(defn- network-pattern?
  "Returns true if stderr indicates network connectivity issues"
  [stderr]
  (or (str/includes? stderr "Could not resolve host")
      (str/includes? stderr "Connection refused")
      (str/includes? stderr "Failed to connect")
      (str/includes? stderr "timed out")
      (str/includes? stderr "Network is unreachable")
      (str/includes? stderr "unable to access")
      (str/includes? stderr "The requested URL returned error")))

(defn- detect-by-pattern
  "Fallback pattern matching for unknown exit codes"
  [stderr]
  (cond
    (conflict-pattern? stderr) :conflict
    (no-remote-pattern? stderr) :no-remote
    (network-pattern? stderr) :network
    :else :other))

(defn- detect-exit-1-error
  "Exit 1 is typically conflicts, but could be other errors"
  [stderr]
  (cond
    (conflict-pattern? stderr) :conflict
    (no-remote-pattern? stderr) :no-remote
    (network-pattern? stderr) :network
    :else :other))

(defn- detect-fatal-error
  "Exit 128 indicates fatal errors"
  [stderr]
  (cond
    ;; Check for conflicts first - newer git (2.51+) uses exit 128 for divergent branches
    (conflict-pattern? stderr) :conflict
    (no-remote-pattern? stderr) :no-remote
    (network-pattern? stderr) :network
    :else :other))

(defn- detect-error-type
  "Detects error type using exit code and stderr patterns.
  
  Uses a multi-layered approach:
  - Exit code 1: typically conflicts, check patterns to confirm
  - Exit code 128: fatal errors (no remote, network issues)
  - Other codes: fall back to pattern matching"
  [exit-code stderr]
  (let [error-type (cond
                     (= 1 exit-code)
                     (detect-exit-1-error stderr)

                     (= 128 exit-code)
                     (detect-fatal-error stderr)

                     :else
                     (detect-by-pattern stderr))]

    ;; Log unrecognized patterns to stderr for debugging
    (when (and (= error-type :other)
               (not (str/blank? stderr)))
      (binding [*out* *err*]
        (println "Unrecognized git pull error pattern:"
                 "exit-code:" exit-code
                 "stderr:" stderr)))

    ;; Build response
    (if (= error-type :no-remote)
      {:success true :pulled? false :error nil :error-type :no-remote}
      {:success false :pulled? false :error stderr :error-type error-type})))

(defn pull-latest
  "Pulls the latest changes from remote.

  Distinguishes between different failure types to enable appropriate handling.

  Parameters:
  - base-dir: Base directory of the git repository
  - branch-name: Name of the branch to pull

  Returns a map with:
  - :success - boolean indicating if operation succeeded (true for exit 0 or :no-remote)
  - :pulled? - boolean indicating if changes were pulled (true only for exit 0)
  - :error - error message string (or nil if successful/no-remote)
  - :error-type - keyword indicating error type (:no-remote | :conflict | :network | :other, or nil if successful)"
  [base-dir branch-name]
  {:pre [(string? base-dir)
         (not (clojure.string/blank? base-dir))
         (string? branch-name)
         (not (clojure.string/blank? branch-name))]}
  (try
    (let [result (sh/sh "git" "-C" base-dir "pull" "origin" branch-name)
          stderr (str/trim (:err result))
          exit-code (:exit result)]
      (if (zero? exit-code)
        {:success true
         :pulled? true
         :error nil
         :error-type nil}
        ;; Non-zero exit - use multi-layered error detection
        (detect-error-type exit-code stderr)))
    (catch Exception e
      {:success false
       :pulled? false
       :error (.getMessage e)
       :error-type :other})))

(defn derive-project-name
  "Extracts the project name from a project directory path.

  Parameters:
  - project-dir: Path to the project directory

  Returns a map with:
  - :success - boolean indicating if operation succeeded
  - :name - project name string (last component of path)
  - :error - error message string (or nil if successful)"
  [project-dir]
  {:pre [(string? project-dir)
         (not (clojure.string/blank? project-dir))]}
  (try
    (let [file (fs/file project-dir)
          name (.getName file)]
      (if (str/blank? name)
        {:success false
         :name nil
         :error "Could not extract project name from path"}
        {:success true
         :name name
         :error nil}))
    (catch Exception e
      {:success false
       :name nil
       :error (.getMessage e)})))

(defn derive-worktree-path
  "Generates a worktree path from a project directory, title, and task ID.

  The worktree path includes the task ID prefix and respects the configured
  word limit from :branch-title-words (defaults to 4 words).

  The worktree path format depends on the :worktree-prefix config:
  - :project-name (default): <parent-dir>/<project-name>-<id>-<title-slug>
  - :none: <parent-dir>/<id>-<title-slug>

  The title slug is generated using util/sanitize-branch-name which:
  - Takes first N words from title (N = :branch-title-words, default 4)
  - Converts to lowercase
  - Replaces spaces with dashes
  - Removes all special characters (keeping only a-z, 0-9, -)
  - Prepends task ID

  Parameters:
  - project-dir: Path to the project directory
  - title: Story or task title to convert to path
  - task-id: The task or story ID number
  - config: Configuration map containing :worktree-prefix and :branch-title-words

  Returns a map with:
  - :success - boolean indicating if operation succeeded
  - :path - worktree path string
  - :error - error message string (or nil if successful)

  Examples:
  (derive-worktree-path \"/Users/test/mcp-tasks\" \"Fix parser bug\" 123
                        {:worktree-prefix :project-name :branch-title-words 4})
  ;; => {:success true :path \"/Users/test/mcp-tasks-123-fix-parser-bug\" :error nil}

  (derive-worktree-path \"/Users/test/mcp-tasks\" \"Fix parser bug\" 123
                        {:worktree-prefix :none :branch-title-words 2})
  ;; => {:success true :path \"/Users/test/123-fix-parser\" :error nil}"
  [project-dir title task-id config]
  {:pre [(string? project-dir)
         (not (clojure.string/blank? project-dir))
         (string? title)
         (not (clojure.string/blank? title))
         (int? task-id)
         (map? config)]}
  (try
    (let [worktree-prefix (:worktree-prefix config :project-name)
          word-limit (get config :branch-title-words 4)
          ;; Generate ID-prefixed slug using sanitize-branch-name
          id-slug (util/sanitize-branch-name title task-id word-limit)
          parent-dir (fs/parent project-dir)

          ;; Build path based on prefix mode
          worktree-path (if (= worktree-prefix :none)
                          (str parent-dir "/" id-slug)
                          (let [name-result (derive-project-name project-dir)]
                            (if-not (:success name-result)
                              (throw (ex-info (:error name-result)
                                              {:operation "derive-project-name"}))
                              (let [project-name (:name name-result)]
                                (str parent-dir "/" project-name "-" id-slug)))))]

      {:success true
       :path worktree-path
       :error nil})
    (catch Exception e
      {:success false
       :path nil
       :error (.getMessage e)})))

(defn list-worktrees
  "Lists all git worktrees in the repository.

  Parses the porcelain format output from 'git worktree list --porcelain'.

  Parameters:
  - project-dir: Path to the project directory

  Returns a map with:
  - :success - boolean indicating if operation succeeded
  - :worktrees - vector of maps with :path, :head, :branch (or :detached)
  - :error - error message string (or nil if successful)"
  [project-dir]
  {:pre [(string? project-dir)
         (not (clojure.string/blank? project-dir))]}
  (try
    (let [result (sh/sh "git" "-C" project-dir "worktree" "list" "--porcelain")]
      (if (zero? (:exit result))
        (let [output (str/trim (:out result))
              entries (if (str/blank? output)
                        []
                        (str/split output #"\n\n"))
              worktrees (for [entry entries]
                          (let [lines (str/split-lines entry)
                                parse-line (fn [line]
                                             (if-let [[_ k v] (re-matches #"(\w+)\s+(.*)" line)]
                                               [k v]
                                               (when-let [[_ k] (re-matches #"(\w+)" line)]
                                                 [k true])))
                                pairs (keep parse-line lines)
                                data (into {} pairs)]
                            (cond-> {:path (get data "worktree")
                                     :head (get data "HEAD")}
                              (contains? data "branch")
                              (assoc :branch (str/replace (get data "branch") #"^refs/heads/" ""))

                              (get data "detached")
                              (assoc :detached true))))]
          {:success true
           :worktrees (vec worktrees)
           :error nil})
        {:success false
         :worktrees nil
         :error (str/trim (:err result))}))
    (catch Exception e
      {:success false
       :worktrees nil
       :error (.getMessage e)})))

(defn find-worktree-for-branch
  "Finds the worktree (if any) that has the given branch checked out.

  Parameters:
  - project-dir: Path to the project directory
  - branch-name: Name of the branch to search for

  Returns:
  - {:success true :worktree {...} :error nil} if branch found in a worktree
  - {:success true :worktree nil :error nil} if branch not in any worktree
  - {:success false :error \"...\"} on error"
  [project-dir branch-name]
  {:pre [(string? project-dir)
         (not (clojure.string/blank? project-dir))
         (string? branch-name)
         (not (clojure.string/blank? branch-name))]}
  (let [result (list-worktrees project-dir)]
    (if (:success result)
      (let [matching-worktree (->> (:worktrees result)
                                   (filter #(= branch-name (:branch %)))
                                   first)]
        {:success true
         :worktree matching-worktree
         :error nil})
      {:success false
       :worktree nil
       :error (:error result)})))

(defn worktree-exists?
  "Checks if a worktree exists at the given path.

  Parameters:
  - project-dir: Path to the project directory
  - worktree-path: Path to check for worktree existence

  Returns a map with:
  - :success - boolean indicating if check succeeded
  - :exists? - boolean indicating if worktree exists
  - :worktree - worktree info map (or nil if doesn't exist)
  - :error - error message string (or nil if successful)"
  [project-dir worktree-path]
  {:pre [(string? project-dir)
         (not (clojure.string/blank? project-dir))
         (string? worktree-path)
         (not (clojure.string/blank? worktree-path))]}
  (let [result (list-worktrees project-dir)]
    (if-not (:success result)
      (assoc result :exists? nil :worktree nil)
      (let [worktree (first (filter #(= (:path %) worktree-path)
                                    (:worktrees result)))]
        {:success true
         :exists? (some? worktree)
         :worktree worktree
         :error nil}))))

(defn worktree-branch
  "Returns the branch name of a worktree.

  Parameters:
  - worktree-path: Path to the worktree directory

  Returns a map with:
  - :success - boolean indicating if operation succeeded
  - :branch - branch name string (or nil if failed/detached)
  - :detached? - boolean indicating if HEAD is detached
  - :error - error message string (or nil if successful)"
  [worktree-path]
  {:pre [(string? worktree-path)
         (not (clojure.string/blank? worktree-path))]}
  (try
    (let [result (sh/sh "git" "-C" worktree-path "rev-parse" "--abbrev-ref" "HEAD")]
      (if (zero? (:exit result))
        (let [branch (str/trim (:out result))]
          (if (= "HEAD" branch)
            {:success true
             :branch nil
             :detached? true
             :error nil}
            {:success true
             :branch branch
             :detached? false
             :error nil}))
        {:success false
         :branch nil
         :detached? nil
         :error (str/trim (:err result))}))
    (catch Exception e
      {:success false
       :branch nil
       :detached? nil
       :error (.getMessage e)})))

(defn create-worktree
  "Creates a new git worktree.

  Parameters:
  - project-dir: Path to the project directory
  - worktree-path: Path where the worktree should be created
  - branch-name: Name of the branch for the worktree
  - base-branch: Name of the branch to base branch-name on

  With base-branch, creates the branch.

  Returns a map with:
  - :success - boolean indicating if creation succeeded
  - :error - error message string (or nil if successful)"
  ([project-dir worktree-path branch-name]
   (create-worktree project-dir worktree-path branch-name nil))
  ([project-dir worktree-path branch-name base-branch]
   {:pre [(string? project-dir)
          (not (clojure.string/blank? project-dir))
          (string? worktree-path)
          (not (clojure.string/blank? worktree-path))
          (string? branch-name)
          (not (clojure.string/blank? branch-name))]}
   (try
     (let [result (if base-branch
                    (sh/sh "git" "-C" project-dir
                           "worktree" "add"
                           worktree-path
                           "-b"
                           branch-name
                           base-branch)
                    (sh/sh "git" "-C" project-dir
                           "worktree" "add"
                           worktree-path
                           branch-name))]
       (if (zero? (:exit result))
         {:success true
          :error nil}
         {:success false
          :error (str/trim (:err result))}))
     (catch Exception e
       {:success false
        :error (.getMessage e)}))))

(defn remove-worktree
  "Removes a git worktree.

  Parameters:
  - project-dir: Path to the project directory
  - worktree-path: Path to the worktree to remove

  Returns a map with:
  - :success - boolean indicating if removal succeeded
  - :error - error message string (or nil if successful)"
  [project-dir worktree-path]
  {:pre [(string? project-dir)
         (not (clojure.string/blank? project-dir))
         (string? worktree-path)
         (not (clojure.string/blank? worktree-path))]}
  (try
    (let [result (sh/sh "git" "-C" project-dir "worktree" "remove" worktree-path)]
      (if (zero? (:exit result))
        {:success true
         :error nil}
        {:success false
         :error (str/trim (:err result))}))
    (catch Exception e
      {:success false
       :error (.getMessage e)})))
(ns mcp-tasks.schema
  "Malli schemas for task management system.

  Uses lazy-loading via requiring-resolve and compiled validators with delays
  to avoid loading Malli at namespace load time.")

;; Schema Definitions

(def Relation
  "Schema for task relationships.

  Defines how one task relates to another through various relationship types."
  [:map
   [:id :int]
   [:relates-to :int]
   [:as-type [:enum :blocked-by :related :discovered-during]]])

(def Task
  "Schema for a task entity.

  A task represents a unit of work with metadata, status, and relationships."
  [:map
   [:id :int]
   [:parent-id {:optional true} [:maybe :int]]
   [:status [:enum :open :closed :in-progress :blocked :deleted]]
   [:title :string]
   [:description :string]
   [:design :string]
   [:category :string]
   [:type [:enum :task :bug :feature :story :chore]]
   [:meta [:map-of :string :string]]
   [:relations [:vector Relation]]])

(def blocking-statuses
  "Set of task statuses that prevent completion or deletion of parent tasks.

  Tasks with these statuses are considered 'blocking' because they represent
  incomplete or problematic work. Tasks with :status :closed or :status :deleted
  are considered non-blocking as they represent completed or removed work."
  #{:open :in-progress :blocked})

;; Validation Helpers

;; Lazy-loaded Malli functions
;; Using requiring-resolve to avoid loading malli.core at namespace load time

;; Compiled validators using delays
;; Both requiring-resolve AND validator compilation happen lazily

;; USE_MALLI Environment Variable
;;
;; Why use USE_MALLI instead of just :bb reader conditional?
;;
;; The USE_MALLI environment variable provides more flexibility than platform-only
;; reader conditionals:
;;
;; - BB tests run with full Malli validation (USE_MALLI=true set in bb.edn test task)
;; - Standalone uberscript has no Malli dependencies (USE_MALLI not set, no-op validators)
;; - JVM mode always uses full validation (Malli always available on classpath)
;;
;; This opt-in approach allows testing the BB implementation with validation enabled
;; while keeping the standalone uberscript lean and dependency-free.

(def relation-validator
  "Compiled validator for Relation schema."
  #?(:bb (if (System/getenv "USE_MALLI")
           (delay ((requiring-resolve 'malli.core/validator) Relation))
           (delay (fn [_] true)))
     :clj (delay ((requiring-resolve 'malli.core/validator) Relation))))

(def task-validator
  "Compiled validator for Task schema."
  #?(:bb (if (System/getenv "USE_MALLI")
           (delay ((requiring-resolve 'malli.core/validator) Task))
           (delay (fn [_] true)))
     :clj (delay ((requiring-resolve 'malli.core/validator) Task))))

(def relation-explainer
  "Compiled explainer for Relation schema."
  #?(:bb (if (System/getenv "USE_MALLI")
           (delay ((requiring-resolve 'malli.core/explainer) Relation))
           (delay (fn [_] nil)))
     :clj (delay ((requiring-resolve 'malli.core/explainer) Relation))))

(def task-explainer
  "Compiled explainer for Task schema."
  #?(:bb (if (System/getenv "USE_MALLI")
           (delay ((requiring-resolve 'malli.core/explainer) Task))
           (delay (fn [_] nil)))
     :clj (delay ((requiring-resolve 'malli.core/explainer) Task))))

(defn valid-relation?
  "Validate a relation map against the Relation schema."
  [relation]
  #_{:clj-kondo/ignore [:type-mismatch]}
  (@relation-validator relation))

(defn valid-task?
  "Validate a task map against the Task schema."
  [task]
  #_{:clj-kondo/ignore [:type-mismatch]}
  (@task-validator task))

(defn explain-relation
  "Explain why a relation map is invalid.
  Returns nil if valid, explanation map if invalid."
  [relation]
  #_{:clj-kondo/ignore [:type-mismatch]}
  (@relation-explainer relation))

(defn explain-task
  "Explain why a task map is invalid.
  Returns nil if valid, explanation map if invalid."
  [task]
  #_{:clj-kondo/ignore [:type-mismatch]}
  (@task-explainer task))

;; Example Data

(def example-relation
  "Example relation for testing and documentation."
  {:id 1
   :relates-to 2
   :as-type :blocked-by})

(def example-task
  "Example task for testing and documentation."
  {:id 1
   :parent-id nil
   :status :open
   :title "Create schema namespace"
   :description "Add Malli schemas for Task and Relation"
   :design "Use malli.core for validation"
   :category "simple"
   :type :task
   :meta {"priority" "high"}
   :relations [example-relation]})
(ns mcp-tasks.tasks-file
  "Low-level file operations for EDNL (EDN Lines) task storage.

  EDNL format stores one task per line as an EDN map. All write operations
  are atomic using temp files."
  (:require
    [babashka.fs :as fs]
    [clojure.edn :as edn]
    [clojure.string :as str]
    [mcp-tasks.schema :as schema]))

;; Helper Functions

(defn- ensure-parent-dir
  "Create parent directory if it doesn't exist."
  [file]
  (when-let [parent (fs/parent file)]
    (fs/create-dirs parent)))

(defn- read-task-line
  "Parse a single line as EDN and validate against Task schema.

  Returns task map if valid, nil if invalid (with warning logged)."
  [line line-number]
  (when-not (str/blank? line)
    (try
      (let [task (edn/read-string line)]
        (if (schema/valid-task? task)
          task
          (do
            (binding [*out* *err*]
              (println (format "Warning: Invalid task at line %d: %s"
                               line-number
                               (pr-str (schema/explain-task task)))))
            nil)))
      (catch Exception e
        (binding [*out* *err*]
          (println (format "Warning: Malformed EDN at line %d: %s"
                           line-number
                           (.getMessage e))))
        nil))))

(defn- write-ednl-atomic
  "Write tasks to file atomically using temp file and rename.

  Creates parent directories if needed."
  [file-path tasks]
  (ensure-parent-dir file-path)
  (let [temp-file (str file-path ".tmp")
        content (str/join "\n" (map pr-str tasks))]
    (spit temp-file content)
    (fs/move temp-file file-path {:replace-existing true})))

;; Public API

(defn read-ednl
  "Read all tasks from an EDNL (EDN Lines) file.

  Returns vector of task maps. Missing files return empty vector.
  Malformed or invalid lines are skipped with warnings."
  [file-path]
  (if (fs/exists? file-path)
    (let [content (slurp file-path)
          lines (str/split-lines content)]
      (into []
            (keep-indexed (fn [idx line]
                            (read-task-line line (inc idx))))
            lines))
    []))

(defn append-task
  "Append a task to the end of an EDNL file.

  Write operation is atomic. Validates task against schema before writing.
  Creates parent directories if needed."
  [file-path task]
  (when-not (schema/valid-task? task)
    (throw (ex-info "Invalid task schema"
                    {:task task
                     :explanation (schema/explain-task task)})))
  (let [existing-tasks (read-ednl file-path)
        new-tasks (conj existing-tasks task)]
    (write-ednl-atomic file-path new-tasks)))

(defn prepend-task
  "Prepend a task to the beginning of an EDNL file.

  Write operation is atomic. Validates task against schema before writing.
  Creates parent directories if needed."
  [file-path task]
  (when-not (schema/valid-task? task)
    (throw (ex-info "Invalid task schema"
                    {:task task
                     :explanation (schema/explain-task task)})))
  (let [existing-tasks (read-ednl file-path)
        new-tasks (into [task] existing-tasks)]
    (write-ednl-atomic file-path new-tasks)))

(defn replace-task
  "Replace a task by id in an EDNL file.

  Write operation is atomic. Validates task against schema before writing.
  Throws ex-info if task id not found."
  [file-path task]
  (when-not (schema/valid-task? task)
    (throw (ex-info "Invalid task schema"
                    {:task task
                     :explanation (schema/explain-task task)})))
  (let [existing-tasks (read-ednl file-path)
        task-id (:id task)
        task-index (first (keep-indexed
                            (fn [idx t]
                              (when (= (:id t) task-id)
                                idx))
                            existing-tasks))]
    (when (nil? task-index)
      (throw (ex-info "Task not found"
                      {:id task-id
                       :file file-path})))
    (let [new-tasks (assoc existing-tasks task-index task)]
      (write-ednl-atomic file-path new-tasks))))

(defn delete-task
  "Remove a task by id from an EDNL file.

  Write operation is atomic. Throws ex-info if task id not found."
  [file-path id]
  (let [existing-tasks (read-ednl file-path)
        new-tasks (into []
                        (remove #(= (:id %) id))
                        existing-tasks)]
    (when (= (count new-tasks) (count existing-tasks))
      (throw (ex-info "Task not found"
                      {:id id
                       :file file-path})))
    (write-ednl-atomic file-path new-tasks)))

(defn write-tasks
  "Write a collection of tasks to an EDNL file.

  Write operation is atomic. Validates all tasks against schema before writing.
  Creates parent directories if needed."
  [file-path tasks]
  (doseq [task tasks]
    (when-not (schema/valid-task? task)
      (throw (ex-info "Invalid task schema"
                      {:task task
                       :explanation (schema/explain-task task)}))))
  (write-ednl-atomic file-path tasks))
(ns mcp-tasks.tasks
  "High-level task management with in-memory state.

  Provides query and mutation operations over an in-memory task store,
  backed by EDNL file storage."
  (:require
    [clojure.string :as str]
    [mcp-tasks.schema :as schema]
    [mcp-tasks.tasks-file :as tasks-file]))

;; State Management

(defonce ^{:doc "Ordered vector of task IDs (matches disk order)."}
  task-ids
  (atom []))

(defonce ^{:doc "Map of task-id → task-map."}
  tasks
  (atom {}))

(defonce ^{:doc "Ordered vector of completed task IDs (matches disk order in complete.ednl)."}
  complete-task-ids
  (atom []))

(defonce ^{:doc "Map of parent-id → set of child-ids."}
  parent-children
  (atom {}))

(defonce ^{:doc "Map of child-id → parent-id."}
  child-parent
  (atom {}))

(defonce ^{:doc "Monotonically increasing ID generator."}
  next-id
  (volatile! 1))

;; State Initialization Helpers

(defn- reset-state!
  "Reset all state atoms to empty values."
  []
  (reset! task-ids [])
  (reset! complete-task-ids [])
  (reset! tasks {})
  (reset! parent-children {})
  (reset! child-parent {}))

(defn- update-next-id!
  "Update next-id to be greater than all existing task IDs.

  Optionally accepts :additional-ids (e.g., IDs from complete.ednl) to ensure
  monotonicity across both active and completed tasks."
  [& {:keys [additional-ids]}]
  (let [active-max (apply max 0 @task-ids)
        complete-max (if additional-ids
                       (apply max 0 additional-ids)
                       0)
        max-id (max active-max complete-max)]
    (vreset! next-id (inc max-id))))

(defn- build-parent-child-maps
  "Build parent-children and child-parent maps from task collection.

  Returns [parent-children-map child-parent-map]."
  [task-coll]
  (reduce
    (fn [[pc cp] task]
      (if-let [parent-id (:parent-id task)]
        [(update pc parent-id (fnil conj #{}) (:id task))
         (assoc cp (:id task) parent-id)]
        [pc cp]))
    [{} {}]
    task-coll))

;; Query API

(defn get-task
  "Get task by ID.

  Returns task map or nil if not found."
  [id]
  (get @tasks id))

(defn get-children
  "Get all child tasks for a parent ID.

  Returns vector of child task maps (empty if no children)."
  [parent-id]
  (let [child-ids (get @parent-children parent-id #{})]
    (mapv #(get @tasks %) child-ids)))

(defn get-next-incomplete-by-category
  "Find first incomplete task in the specified category.

  Returns task map or nil if no incomplete tasks found."
  [category]
  (let [ids @task-ids
        task-map @tasks]
    (->> ids
         (map #(get task-map %))
         (filter #(and (= (:category %) category)
                       (not= (:status %) :closed)))
         first)))

(defn get-next-incomplete-by-parent
  "Find first incomplete child task for a parent ID.

  Returns task map or nil if no incomplete children found."
  [parent-id]
  (let [children (get-children parent-id)]
    (->> children
         (filter #(not= (:status %) :closed))
         first)))

(defn get-next-incomplete
  "Find first incomplete task matching optional filters.

  Filters are AND-ed together:
  - category: Task category must match exactly
  - parent-id: Task must be a child of this parent
  - title-pattern: Task title must match pattern (regex or substring)

  Returns task map or nil if no matching incomplete tasks found."
  [& {:keys [category parent-id title-pattern]}]
  (let [ids @task-ids
        task-map @tasks
        ;; Build regex if possible, otherwise use substring match
        title-matcher (when title-pattern
                        (try
                          (re-pattern title-pattern)
                          (catch Exception _
                            ;; Fall back to substring match
                            nil)))
        title-match? (cond
                       (nil? title-pattern) (constantly true)
                       title-matcher #(re-find title-matcher (:title % ""))
                       :else #(str/includes? (:title % "") title-pattern))]
    (->> ids
         (map #(get task-map %))
         (filter #(not= (:status %) :closed))
         (filter #(or (nil? category) (= (:category %) category)))
         (filter #(or (nil? parent-id) (= (:parent-id %) parent-id)))
         (filter title-match?)
         first)))

(defn get-tasks
  "Find all tasks matching optional filters.

  Filters are AND-ed together:
  - task-id: Task ID must match exactly
  - category: Task category must match exactly
  - parent-id: Task must be a child of this parent
  - title-pattern: Task title must match pattern (regex or substring)
  - type: Task type must match exactly (keyword: :task, :bug, :feature, :story, :chore)
  - status: Task status must match exactly (keyword: :open, :closed, :in-progress, :blocked)
            When nil (default), returns only non-closed tasks
            When :any, returns tasks regardless of status

  Returns vector of task maps in the order they appear in tasks.ednl.
  Returns empty vector if no matching tasks found."
  [& {:keys [task-id category parent-id title-pattern type status]}]
  (let [task-map @tasks
        ;; When status is specified (including :closed) or :any, search both active and completed tasks
        ;; When status is nil, only search active tasks (exclude closed)
        ;; Always preserve file order by iterating through ordered ID vectors
        task-seq (if (or (some? status) (= status :any))
                   (keep #(get task-map %) (concat @task-ids @complete-task-ids))
                   (keep #(get task-map %) @task-ids))
        ;; Build regex if possible, otherwise use substring match
        title-matcher (when title-pattern
                        (try
                          (re-pattern title-pattern)
                          (catch Exception _
                            ;; Fall back to substring match
                            nil)))
        title-match? (cond
                       (nil? title-pattern) (constantly true)
                       title-matcher #(re-find title-matcher (:title % ""))
                       :else #(str/includes? (:title % "") title-pattern))
        ;; Status filter: when nil, exclude closed; when :any, include all; when specified, match exactly
        status-match? (cond
                        (nil? status) #(not= (:status %) :closed)
                        (= status :any) (constantly true)
                        :else #(= (:status %) status))]
    (->> task-seq
         (filter status-match?)
         (filter #(or (nil? task-id) (= (:id %) task-id)))
         (filter #(or (nil? category) (= (:category %) category)))
         (filter #(or (nil? parent-id) (= (:parent-id %) parent-id)))
         (filter #(or (nil? type) (= (:type %) type)))
         (filter title-match?)
         vec)))

(defn find-by-title
  "Find all tasks with exact title match.

  Returns vector of matching tasks (may be empty or contain multiple tasks)."
  [title]
  (let [ids @task-ids
        task-map @tasks]
    (->> ids
         (map #(get task-map %))
         (filter #(= (:title %) title))
         vec)))

(defn verify-task-text
  "Check if task with given ID has text that starts with partial-text.

  Checks both :title and :description fields.
  Returns true if match found, false otherwise."
  [id partial-text]
  (if-let [task (get-task id)]
    (let [title (:title task "")
          description (:description task "")]
      (or (str/starts-with? title partial-text)
          (str/starts-with? description partial-text)))
    false))

;; Mutation API

(defn add-task
  "Add a new task to in-memory state.

  Generates a new task ID and adds the task to all relevant state atoms.
  Options:
  - :prepend? - If true, add at beginning; otherwise add at end (default false)

  Returns the complete task map with the newly assigned ID."
  [task & {:keys [prepend?] :or {prepend? false}}]
  (let [new-id @next-id
        task-with-id (assoc task :id new-id)]
    ;; Validate before adding
    (when-not (schema/valid-task? task-with-id)
      (throw (ex-info "Invalid task schema"
                      {:task task-with-id
                       :explanation (schema/explain-task task-with-id)})))
    ;; Update task-ids
    (if prepend?
      (swap! task-ids #(into [new-id] %))
      (swap! task-ids conj new-id))
    ;; Update tasks map
    (swap! tasks assoc new-id task-with-id)
    ;; Update parent-child maps if needed
    (when-let [parent-id (:parent-id task-with-id)]
      (swap! parent-children update parent-id (fnil conj #{}) new-id)
      (swap! child-parent assoc new-id parent-id))
    ;; Increment next-id
    (vswap! next-id inc)
    task-with-id))

(defn update-task
  "Update an existing task in memory.

  Applies the updates map to the task with given ID.
  Maintains parent-child relationship invariants.
  Throws ex-info if task not found."
  [id updates]
  (when-not (get-task id)
    (throw (ex-info "Task not found" {:id id})))
  (let [old-task (get-task id)
        new-task (merge old-task updates)
        old-parent (:parent-id old-task)
        new-parent (:parent-id new-task)]
    ;; Validate updated task
    (when-not (schema/valid-task? new-task)
      (throw (ex-info "Invalid task schema after update"
                      {:task new-task
                       :explanation (schema/explain-task new-task)})))
    ;; Update tasks map
    (swap! tasks assoc id new-task)
    ;; Update parent-child maps if parent changed
    (when (not= old-parent new-parent)
      ;; Remove from old parent
      (when old-parent
        (swap! parent-children
               (fn [pc]
                 (let [updated (update pc old-parent disj id)]
                   (if (empty? (get updated old-parent))
                     (dissoc updated old-parent)
                     updated))))
        (swap! child-parent dissoc id))
      ;; Add to new parent
      (when new-parent
        (swap! parent-children update new-parent (fnil conj #{}) id)
        (swap! child-parent assoc id new-parent)))
    new-task))

(defn mark-complete
  "Mark a task as complete with optional completion comment.

  Updates task status to :closed and optionally adds comment to description.
  Throws ex-info if task not found."
  [id comment]
  (when-not (get-task id)
    (throw (ex-info "Task not found" {:id id})))
  (let [task (get-task id)
        description (:description task "")
        new-description (if (and comment (not (str/blank? comment)))
                          (str description "\n\nCompleted: " comment)
                          description)]
    (update-task id {:status :closed
                     :description new-description})))

(defn delete-task
  "Remove task from in-memory state.

  Does not modify disk - use move-task! for persistence.
  Throws ex-info if task not found."
  [id]
  (when-not (get-task id)
    (throw (ex-info "Task not found" {:id id})))
  (let [task (get-task id)]
    ;; Remove from task-ids
    (swap! task-ids #(filterv (fn [tid] (not= tid id)) %))
    ;; Remove from tasks map
    (swap! tasks dissoc id)
    ;; Remove from parent-child maps
    (when-let [parent-id (:parent-id task)]
      (swap! parent-children
             (fn [pc]
               (let [updated (update pc parent-id disj id)]
                 (if (empty? (get updated parent-id))
                   (dissoc updated parent-id)
                   updated))))
      (swap! child-parent dissoc id))
    task))

;; Persistence API

(defn load-tasks!
  "Load tasks from EDNL file into memory.

  Resets current state and populates from file.

  Options:
  - :complete-file - Path to complete.ednl to also load completed tasks

  Returns number of tasks loaded from primary file."
  [file-path & {:keys [complete-file]}]
  (reset-state!)
  (let [task-coll (tasks-file/read-ednl file-path)
        ;; Also load completed tasks if complete-file is provided
        complete-coll (when complete-file
                        (tasks-file/read-ednl complete-file))
        ;; Combine both collections for parent-child map building
        all-tasks (concat task-coll complete-coll)
        [pc-map cp-map] (build-parent-child-maps all-tasks)
        ;; Extract IDs from complete tasks
        complete-ids (when complete-coll
                       (mapv :id complete-coll))]
    ;; Populate state with active tasks only in task-ids
    (reset! task-ids (mapv :id task-coll))
    ;; Track completed task IDs in order
    (reset! complete-task-ids (or complete-ids []))
    ;; But include both active and completed tasks in the tasks map
    (reset! tasks (into {}
                        (concat
                          (map (fn [t] [(:id t) t]) task-coll)
                          (map (fn [t] [(:id t) t]) complete-coll))))
    (reset! parent-children pc-map)
    (reset! child-parent cp-map)
    ;; Update next-id considering both active and completed tasks
    (update-next-id! :additional-ids complete-ids)
    (count task-coll)))

(defn save-tasks!
  "Save in-memory tasks to EDNL file.

  Writes tasks in task-ids order to maintain disk ordering.
  Returns number of tasks saved."
  [file-path]
  (let [ids @task-ids
        task-map @tasks
        task-coll (mapv #(get task-map %) ids)]
    ;; Write all tasks atomically
    (tasks-file/write-tasks file-path task-coll)
    (count task-coll)))

(defn move-task!
  "Move task from one file to another.

  Atomically removes task from source file and appends to destination file.
  Updates in-memory state by removing the task (since in-memory state represents
  only tasks.ednl, not complete.ednl).
  Throws ex-info if task not found."
  [id from-file to-file]
  (when-not (get-task id)
    (throw (ex-info "Task not found" {:id id})))
  (let [task (get-task id)]
    ;; Delete from source file
    (tasks-file/delete-task from-file id)
    ;; Append to destination file
    (tasks-file/append-task to-file task)
    ;; Remove from in-memory state since it's no longer in tasks.ednl
    (delete-task id)
    task))

(defn move-tasks!
  "Move multiple tasks from one file to another atomically.

  Removes all tasks from source file and appends to destination file.
  Updates in-memory state by removing all tasks (since in-memory state represents
  only tasks.ednl, not complete.ednl).
  Throws ex-info if any task not found."
  [ids from-file to-file]
  ;; Validate all tasks exist first
  (doseq [id ids]
    (when-not (get-task id)
      (throw (ex-info "Task not found" {:id id}))))

  ;; Get all tasks
  (let [tasks-to-move (mapv get-task ids)]
    ;; Delete all from source file atomically
    (let [remaining-tasks (remove #(contains? (set ids) (:id %))
                                  (tasks-file/read-ednl from-file))]
      (tasks-file/write-tasks from-file remaining-tasks))

    ;; Append all to destination file atomically
    (let [existing-tasks (tasks-file/read-ednl to-file)
          all-tasks (into existing-tasks tasks-to-move)]
      (tasks-file/write-tasks to-file all-tasks))

    ;; Remove all from in-memory state
    (doseq [id ids]
      (delete-task id))

    tasks-to-move))
(ns mcp-clj.log
  (:require
    [clojure.string :as str]))

(def ^:private levels #{:error :warn :info :debug :trace})

(def ^:private level-names
  (reduce
    (fn [res k]
      (assoc res k (str/upper-case (name k))))
    {}
    levels))

(def ^:private aspects
  #{"sse" "http" "rpc" "client" "server" "stdio-server" "tool" "java-sdk"
    "sdk-server-main"})

(defonce ^:private config (atom {}))

(defn enable!
  "Enable logging for the specified level and aspect."
  [level aspect]
  {:pre [(contains? levels level)]}
  (swap! config assoc-in [level aspect] true))

(doseq [aspect aspects]
  (enable! :error aspect)
  (enable! :warn aspect))

(defn disable!
  "Disable logging for the specified level and aspect."
  [level aspect]
  {:pre [(contains? levels level)]}
  (swap! config assoc-in [level aspect] false))

(defn enabled?
  "Check if logging is enabled for the specified level and aspect."
  [level aspect]
  {:pre [(contains? levels level)]}
  (get-in @config [level aspect]))

(defn output
  [level aspect id data]
  (binding [*out* *err*]
    (locking *err*
      (println
        (str (level-names level) " [" aspect "/" (name id) "]"
             (when data (str " " (pr-str data))))))))

(defmacro log
  "Log a message if enabled for the specified level and aspect.
   id - Identifier for the log entry, the namespace is the aspect
   level - One of :error, :warn, :info, :debug, :trace
   aspect - Keyword identifying the aspect being logged
   data - Optional map of data to include"
  [level id & [data]]
  `(let [id#     ~id
         aspect# (namespace id#)]
     (when (enabled? ~level aspect#)
       (output ~level aspect# id# ~data))))

(defmacro error
  [id & [data]]
  `(log :error  ~id ~data))

(defmacro warn
  [id & [data]]
  `(log :warn   ~id ~data))

(defmacro info
  [id & [data]]
  `(log :info   ~id ~data))

(defmacro debug
  [id & [data]]
  `(log :debug  ~id ~data))

(defmacro trace
  [id & [data]]
  `(log :trace  ~id ~data))

;; (enable! :debug "rpc")
;; (enable! :debug "server")
;; (enable! :debug "client")
;; (enable! :debug "http")
;; (enable! :debug "java-sdk")
;; (enable! :debug "sdk-server-main")

(comment
  (enable! :info "http")
  (enable! :info "sse")
  (enable! :debug "rpc")
  (enable! :debug "server")
  (enable! :debug "client")
  (enable! :info "handle-error")
  (disable! :info "handle-error")

  (enable! :debug "fred")
  (debug :fred/bloggs {:hello "some data"})
  (info :sse/send! {:hello "some data"})
  (info :rpc/request {:hello "some data"})
  )
(ns mcp-tasks.tools.helpers
  "General helper functions for tool implementations"
  (:require
    [babashka.fs :as fs]
    [cheshire.core :as json]
    [clojure.string :as str]
    [mcp-clj.log :as log]
    [mcp-tasks.tasks :as tasks]
    [mcp-tasks.tools.git :as git])
  (:import
    (java.io
      RandomAccessFile)))

(defn file-exists?
  "Check if a file exists"
  [file-path]
  (fs/exists? file-path))

(defn ensure-file-exists!
  "Ensure a file exists, creating parent directories and empty file if needed.

  Parameters:
  - file-path: Absolute path to the file

  Side effects:
  - Creates parent directories if they don't exist
  - Creates empty file if it doesn't exist

  Returns: nil"
  [file-path]
  (when-not (file-exists? file-path)
    (fs/create-dirs (fs/parent file-path))
    (spit file-path "")))

(defn task-path
  "Construct task directory paths using resolved tasks directory from config.

  Parameters:
  - config: Configuration map containing :resolved-tasks-dir

  - path-segments: Vector of path segments
                   (e.g., [\"tasks.ednl\"] or [\"story\" \"stories\" \"foo.md\"])

  Returns map with:
  - :absolute - Full filesystem path
  - :relative - Path relative to tasks directory root (for git operations)

  Examples:
    (task-path {:resolved-tasks-dir \"/home/user/.mcp-tasks\"} [\"tasks.ednl\"])
    => {:absolute \"/home/user/.mcp-tasks/tasks.ednl\"
        :relative \"tasks.ednl\"}

    (task-path {:resolved-tasks-dir \"/custom/tasks\"} [\"complete.ednl\"])
    => {:absolute \"/custom/tasks/complete.ednl\"
        :relative \"complete.ednl\"}"
  [config path-segments]
  (let [resolved-tasks-dir (:resolved-tasks-dir config)
        relative-path (str/join "/" path-segments)
        absolute-path (str resolved-tasks-dir "/" relative-path)]
    {:absolute absolute-path
     :relative relative-path}))

(defn prepare-task-file
  "Prepare task file for operations WITHOUT git sync.

  **When to use this function:**
  - Read-only operations (e.g., select-tasks) that only query tasks
  - Operations that don't modify tasks.ednl
  - When you explicitly want local-only behavior without network dependency
  - Called internally by `sync-and-prepare-task-file` after successful pull

  **When NOT to use this function:**
  - Tools that MODIFY tasks.ednl - use `sync-and-prepare-task-file` instead
  - Operations where you need the latest remote state before proceeding

  **What it does:**
  1. Loads tasks from tasks.ednl into memory (from local filesystem)
  2. Returns the absolute file path to tasks.ednl

  **Behavior:**
  - No git operations performed
  - Always works with the current local state
  - Fast and predictable (no network dependency)

  **File locking:**
  Read-only operations typically don't need file locking. However, if this
  is called as part of a modification workflow, ensure it's inside a
  `with-task-lock` block.

  **Parameters:**
  - config: Configuration map

  **Returns:**
  - String: Absolute path to tasks.ednl file

  **Trade-offs:**
  - Pros: Fast, no network dependency, simple behavior
  - Cons: May work with stale data if remote has updates
  - Alternative: Use `sync-and-prepare-task-file` for modification operations

  See also: `sync-and-prepare-task-file` for the syncing version used by
  modification tools."
  [config]
  (let [tasks-path (task-path config ["tasks.ednl"])
        tasks-file (:absolute tasks-path)
        complete-path (task-path config ["complete.ednl"])
        complete-file (:absolute complete-path)]
    (when (file-exists? tasks-file)
      (tasks/load-tasks! tasks-file :complete-file complete-file))
    tasks-file))

(defn sync-and-prepare-task-file
  "Synchronizes with git remote and prepares task file for modification.

  **When to use this function:**
  Use this for tools that MODIFY tasks.ednl (add/update/delete operations).
  Ensures the agent works with the latest git state when starting modifications.

  **When NOT to use this function:**
  - Read-only operations (e.g., select-tasks, work-on) - these can load tasks directly
  - Operations that don't modify tasks.ednl

  **What it does:**
  1. Checks if git sync is enabled via :enable-git-sync? config
  2. If disabled, immediately returns prepare-task-file (skips git operations)
  3. If enabled, pulls latest changes from the git remote (if configured)
  4. Loads tasks from tasks.ednl into memory
  5. Returns the tasks file path for subsequent operations

  **Git sync behavior:**
  - Sync disabled (:enable-git-sync? false): Skips all git operations, loads tasks directly
  - Not a git repository: Skips sync, loads tasks normally (local-only repo)
  - Empty git repository: Skips sync, loads tasks normally (no commits yet)
  - No remote configured: Skips sync, loads tasks normally (acceptable)
  - Pull succeeds: Reloads tasks with latest changes
  - Pull conflicts: Returns error map - operation must be aborted
  - Network errors: Returns error map - operation must be aborted

  **File locking:**
  This function should be called INSIDE a `with-task-lock` block to prevent
  concurrent file modifications. The git pull happens after lock acquisition
  but before modification. Git operations themselves are NOT locked - last
  writer wins for commits/pushes.

  **Parameters:**
  - config: Configuration map with :resolved-tasks-dir and :enable-git-sync?

  **Returns:**
  - Success: String path to tasks.ednl file
  - Failure: {:success false :error \"...\" :error-type :conflict|:network|:other}

  **Error handling:**
  Tools should check if the return value is a map with `:success false`:
  ```clojure
  (let [sync-result (helpers/sync-and-prepare-task-file config)]
    (if (and (map? sync-result) (false? (:success sync-result)))
      ;; Handle error - return tool error response
      (helpers/build-tool-error-response
        (case (:error-type sync-result)
          :conflict (str \"Pull failed with conflicts. Resolve manually in \" tasks-dir)
          :network (str \"Pull failed: \" (:error sync-result))
          (str \"Pull failed: \" (:error sync-result)))
        \"tool-name\"
        {:error-type (:error-type sync-result)})
      ;; Success - sync-result is the tasks-file path
      (let [tasks-file sync-result]
        ;; ... modify tasks ...
        (tasks/save-tasks! tasks-file)
        ;; Return result for git commit outside lock
        {...})))))
  ```

  **Trade-offs:**
  - Pros: Agents always work with latest state, reduces conflicts
  - Cons: Slightly slower due to network round-trip, requires network connectivity
  - Alternative: Use `prepare-task-file` for faster local-only operations

  See also: `prepare-task-file` for the simpler non-syncing version."
  [config]
  ;; Check if git sync is enabled
  (if-not (:enable-git-sync? config)
    ;; Sync disabled - skip git operations and just load tasks
    (prepare-task-file config)
    ;; Sync enabled - proceed with git pull
    (let [tasks-dir (:resolved-tasks-dir config)
          branch-result (git/get-current-branch tasks-dir)]
      (if-not (:success branch-result)
        ;; Failed to get current branch - check if it's an acceptable condition
        (let [error-msg (:error branch-result)]
          (if (or (str/includes? error-msg "not a git repository")
                  (str/includes? error-msg "unknown revision"))
            ;; Not a git repository or empty git repository - skip git sync and just load tasks
            (prepare-task-file config)
            ;; Other git error - return error map
            {:success false
             :error error-msg
             :error-type :other}))
        ;; Got branch name - proceed with pull
        (let [pull-result (git/pull-latest tasks-dir (:branch branch-result))]
          (if (:success pull-result)
            ;; Pull succeeded or no remote configured - proceed with loading tasks
            (prepare-task-file config)
            ;; Pull failed - return error map
            {:success false
             :error (:error pull-result)
             :error-type (:error-type pull-result)}))))))

(defn truncate-title
  "Truncate a title to a maximum length, adding ellipsis if needed.

  Parameters:
  - title: The title string to truncate
  - max-length: Maximum length (default 50)

  Returns truncated string with '...' suffix if longer than max-length."
  ([title]
   (truncate-title title 50))
  ([title max-length]
   (if (> (count title) max-length)
     (str (subs title 0 (- max-length 3)) "...")
     title)))

(defn build-tool-error-response
  "Build standardized two-content-item error response.

  Parameters:
  - error-message: Human-readable error message (string)
  - operation: Operation that failed (string)
  - error-metadata: Additional metadata map to include

  Returns error response map with :content and :isError keys."
  [error-message operation error-metadata]
  {:content [{:type "text"
              :text error-message}
             {:type "text"
              :text (json/generate-string
                      {:error error-message
                       :metadata (merge {:attempted-operation operation}
                                        error-metadata)})}]
   :isError true})

(defn- try-acquire-lock-with-timeout
  "Attempt to acquire file lock with timeout using polling.
  
  Polling is necessary because Java's FileChannel.tryLock() doesn't support
  timeout parameters - it either succeeds immediately or returns nil.
  
  Returns the acquired lock on success, nil on timeout."
  [file-channel timeout-ms poll-interval-ms]
  (let [deadline (+ (System/currentTimeMillis) timeout-ms)]
    (loop []
      (if-let [acquired-lock (.tryLock file-channel)]
        acquired-lock
        (let [now (System/currentTimeMillis)]
          (when (< now deadline)
            (Thread/sleep poll-interval-ms)
            (recur)))))))

(defn with-task-lock
  "Execute function f while holding an exclusive file lock on tasks.ednl.

  Provides cross-process file locking to prevent concurrent task modifications.
  Uses polling-based timeout (required by Java FileLock API limitations).

  Parameters:
  - config: Configuration map with optional :lock-timeout-ms (default 30000ms)
            and :lock-poll-interval-ms (default 100ms)
  - f: Function to execute while holding the lock (no arguments)

  Returns:
  - Always returns a map (never throws exceptions)
  - Success: Result of calling (f) - typically a map with :isError false
  - Timeout: Tool error map {:content [...] :isError true}
  - Lock error: Tool error map {:content [...] :isError true}
  - Function error: Tool error map {:content [...] :isError true}

  Resource management:
  - Opens RandomAccessFile and gets its FileChannel
  - Acquires exclusive lock with timeout
  - Ensures lock release, channel close, and RAF close in finally block
  - Cleans up resources even on exceptions

  Lock acquisition:
  - Uses .tryLock() with polling (configurable interval, default 100ms)
  - Default timeout: 30000ms (30 seconds)
  - Polling is necessary due to Java FileLock API constraints"
  [config f]
  (let [tasks-path (task-path config ["tasks.ednl"])
        tasks-file (:absolute tasks-path)
        lock-timeout-ms (or (:lock-timeout-ms config) 30000)
        poll-interval-ms (or (:lock-poll-interval-ms config) 100)
        raf (atom nil)
        channel (atom nil)
        lock (atom nil)]
    (try
      ;; Ensure file exists before attempting lock
      (ensure-file-exists! tasks-file)

      ;; Open RandomAccessFile and get its channel
      (let [random-access-file (RandomAccessFile. tasks-file "rw")
            file-channel (.getChannel random-access-file)]
        (reset! raf random-access-file)
        (reset! channel file-channel)

        ;; Try to acquire lock with timeout
        (if-let [acquired-lock (try-acquire-lock-with-timeout
                                 file-channel
                                 lock-timeout-ms
                                 poll-interval-ms)]
          (do
            (reset! lock acquired-lock)
            ;; Lock acquired - execute function with error handling
            (try
              (f)
              (catch Exception e
                ;; Convert any exception from function execution to error map
                (build-tool-error-response
                  (str "Error during task operation: " (.getMessage e))
                  "with-task-lock"
                  {:file tasks-file
                   :error-type (-> e class .getName)
                   :message (.getMessage e)}))))
          ;; Lock acquisition timed out
          (build-tool-error-response
            (str "Failed to acquire lock on tasks file after "
                 lock-timeout-ms "ms. "
                 "Another process may be modifying tasks.")
            "with-task-lock"
            {:file tasks-file
             :timeout-ms lock-timeout-ms})))

      (catch java.io.IOException e
        (build-tool-error-response
          (str "Failed to access lock file: " (.getMessage e))
          "with-task-lock"
          {:file tasks-file
           :error-type "io-error"
           :message (.getMessage e)}))

      (finally
        ;; Always release lock, close channel, and close RAF
        (when-let [l @lock]
          (try
            (.release l)
            (catch Exception e
              (log/warn :lock-release-failed
                        {:error (.getMessage e)
                         :file tasks-file}))))
        (when-let [ch @channel]
          (try
            (.close ch)
            (catch Exception e
              (log/warn :channel-close-failed
                        {:error (.getMessage e)
                         :file tasks-file}))))
        (when-let [r @raf]
          (try
            (.close r)
            (catch Exception e
              (log/warn :raf-close-failed
                        {:error (.getMessage e)
                         :file tasks-file}))))))))

(defn setup-completion-context
  "Prepares common context for task completion and deletion operations.

  Parameters:
  - config: Configuration map with :use-git?, :base-dir
  - tool-name: Name of the calling tool (for error messages)

  Returns either:
  - Error response map (with :isError true) if tasks file not found
  - Context map with:
    - :use-git? - Whether git integration is enabled
    - :tasks-file - Absolute path to tasks.ednl
    - :complete-file - Absolute path to complete.ednl
    - :tasks-rel-path - Relative path to tasks.ednl
    - :complete-rel-path - Relative path to complete.ednl
    - :base-dir - Base directory (may be nil)"
  [config tool-name]
  (let [use-git? (:use-git? config)
        tasks-path (task-path config ["tasks.ednl"])
        complete-path (task-path config ["complete.ednl"])
        tasks-file (:absolute tasks-path)
        complete-file (:absolute complete-path)
        tasks-rel-path (:relative tasks-path)
        complete-rel-path (:relative complete-path)]

    (if-not (file-exists? tasks-file)
      (build-tool-error-response
        "Tasks file not found"
        tool-name
        {:file tasks-file})

      (do
        (tasks/load-tasks! tasks-file :complete-file complete-file)
        {:use-git? use-git?
         :tasks-file tasks-file
         :complete-file complete-file
         :tasks-rel-path tasks-rel-path
         :complete-rel-path complete-rel-path
         :base-dir (:base-dir config)}))))

(defn build-completion-response
  "Build standardized completion response with optional git integration.

  Parameters:
  - msg-text: Human-readable completion message (string)
  - modified-files: Vector of relative file paths that were modified
  - use-git?: Whether git integration is enabled (boolean)
  - git-result: Optional map with :success, :commit-sha, :error keys
  - task-data: Optional map with completed task data (for complete/delete operations)

  Returns response map with :content and :isError keys.
  
  Response structure:
  - Git disabled, no task-data: 1 item (message)
  - Git disabled, with task-data: 2 items (message, task-data JSON)
  - Git enabled, no task-data: 3 items (message, modified-files data, git status)
  - Git enabled, with task-data: 3 items (message, task-data + modified-files, git status)"
  ([msg-text modified-files use-git? git-result]
   (build-completion-response msg-text modified-files use-git? git-result nil))
  ([msg-text modified-files use-git? git-result task-data]
   (if use-git?
     ;; Git enabled: always 3 items
     (let [task-data-with-files (if task-data
                                  (assoc task-data :modified-files modified-files)
                                  {:modified-files modified-files})]
       {:content [{:type "text" :text msg-text}
                  {:type "text" :text (json/generate-string task-data-with-files)}
                  {:type "text"
                   :text (json/generate-string
                           (cond-> {:git-status (if (:success git-result)
                                                  "success"
                                                  "error")
                                    :git-commit (:commit-sha git-result)}
                             (:error git-result)
                             (assoc :git-error (:error git-result))))}]
        :isError false})
     ;; Git disabled: 1 or 2 items depending on task-data
     (if task-data
       {:content [{:type "text" :text msg-text}
                  {:type "text" :text (json/generate-string task-data)}]
        :isError false}
       {:content [{:type "text" :text msg-text}]
        :isError false}))))
(ns mcp-tasks.tools.validation
  "Validation error formatting and task validation utilities"
  (:require
    [clojure.string :as str]
    [mcp-tasks.schema :as schema]
    [mcp-tasks.tasks :as tasks]
    [mcp-tasks.tools.helpers :as helpers]))

(defn format-path-element
  "Format a single element from a Malli :in path.

  Handles keywords, symbols, strings, and numeric indices."
  [element]
  (cond
    (keyword? element) (name element)
    (symbol? element) (name element)
    (string? element) element
    (number? element) (str "[" element "]")
    :else (str element)))

(defn format-field-path
  "Format a Malli :in path into a human-readable field name.

  Returns a string like 'relations[0].as-type' for nested paths."
  [in]
  (if (seq in)
    (str/join "." (map format-path-element in))
    "field"))

(defn format-malli-error
  "Format a Malli validation error into a human-readable message.

  Extracts field path and error details from Malli's explain result.
  Returns a string describing what field failed and why."
  [error]
  (let [in (:in error)
        schema (:schema error)
        value (:value error)
        type (:type error)
        field-name (format-field-path in)]
    (cond
      ;; Enum validation failure
      (and (vector? schema) (= :enum (first schema)))
      (let [allowed-values (rest schema)]
        (format "%s has invalid value %s (expected one of: %s)"
                field-name
                (pr-str value)
                (str/join ", " (map pr-str allowed-values))))

      ;; Type mismatch
      (= type :malli.core/invalid-type)
      (format "%s has invalid type (got: %s, expected: %s)"
              field-name
              (pr-str value)
              (pr-str schema))

      ;; Missing required field
      (= type :malli.core/missing-key)
      (format "missing required field: %s" field-name)

      ;; Generic fallback
      :else
      (format "%s failed validation: %s" field-name (pr-str error)))))

(defn format-validation-errors
  "Format Malli validation result into human-readable error messages.

  Takes the result from schema/explain-task and returns a formatted
  string with specific field errors."
  [validation-result]
  (if-let [errors (:errors validation-result)]
    (str/join "; " (map format-malli-error errors))
    (pr-str validation-result)))

;; Task validation functions

(defn validate-task-exists
  "Validate that a task exists.

  Returns error response map if validation fails, nil if successful."
  [task-id operation tasks-file & {:keys [additional-metadata]}]
  (when-not (tasks/get-task task-id)
    (helpers/build-tool-error-response
      "Task not found"
      operation
      (merge {:task-id task-id :file tasks-file}
             additional-metadata))))

(defn validate-parent-id-exists
  "Validate that a parent task exists if parent-id is provided and non-nil.

  Returns error response map if validation fails, nil if successful."
  [parent-id operation task-id tasks-file error-message & {:keys [additional-metadata]}]
  (when (and parent-id (not (tasks/get-task parent-id)))
    (helpers/build-tool-error-response
      error-message
      operation
      (merge {:task-id task-id :parent-id parent-id :file tasks-file}
             additional-metadata))))

(defn validate-task-schema
  "Validate that a task conforms to the schema.

  Returns error response map if validation fails, nil if successful."
  [task operation task-id tasks-file]
  (when-let [validation-result (schema/explain-task task)]
    (let [formatted-errors (format-validation-errors validation-result)
          error-message (str "Invalid task field values: " formatted-errors)]
      (helpers/build-tool-error-response
        error-message
        operation
        {:task-id task-id
         :validation-errors (pr-str validation-result)
         :file tasks-file}))))

(defn find-task-by-identifiers
  "Find a task by task-id and/or title using exact match.

  At least one of task-id or title must be provided.
  If both are provided, they must refer to the same task.

  Parameters:
  - task-id: Optional integer task ID
  - title: Optional string for exact title match
  - operation: String operation name for error messages (e.g., 'complete-task', 'delete-task')
  - tasks-file: Path to tasks file for error metadata

  Returns:
  - Task map if found, OR
  - Error response map with :isError true"
  [task-id title operation tasks-file]
  ;; Validate at least one identifier provided
  (if (and (nil? task-id) (nil? title))
    (helpers/build-tool-error-response
      "Must provide either task-id or title"
      operation
      {:task-id task-id
       :title title})

    ;; Find task by ID or exact title match
    (let [task-by-id (when task-id (tasks/get-task task-id))
          tasks-by-title (when title (tasks/find-by-title title))]

      (cond
        ;; Both provided - verify they match
        (and task-id title)
        (cond
          (nil? task-by-id)
          (helpers/build-tool-error-response
            "Task ID not found"
            operation
            {:task-id task-id
             :file tasks-file})

          (empty? tasks-by-title)
          (helpers/build-tool-error-response
            "No task found with exact title match"
            operation
            {:title title
             :file tasks-file})

          (not (some #(= (:id %) task-id) tasks-by-title))
          (helpers/build-tool-error-response
            "Task ID and title do not refer to the same task"
            operation
            {:task-id task-id
             :title title
             :task-by-id task-by-id
             :tasks-by-title (mapv :id tasks-by-title)
             :file tasks-file})

          :else task-by-id)

        ;; Only ID provided
        task-id
        (or task-by-id
            (helpers/build-tool-error-response
              "Task ID not found"
              operation
              {:task-id task-id
               :file tasks-file}))

        ;; Only title provided
        title
        (cond
          (empty? tasks-by-title)
          (helpers/build-tool-error-response
            "No task found with exact title match"
            operation
            {:title title
             :file tasks-file})

          (> (count tasks-by-title) 1)
          (helpers/build-tool-error-response
            "Multiple tasks found with same title - use task-id to disambiguate"
            operation
            {:title title
             :matching-task-ids (mapv :id tasks-by-title)
             :matching-tasks tasks-by-title
             :file tasks-file})

          :else (first tasks-by-title))))))
(ns mcp-tasks.tool.delete-task
  "MCP tool for deleting tasks from the task queue.

  This namespace implements the delete-task tool, which removes tasks by
  marking them with :status :deleted and moving them to complete.ednl.
  This provides a soft-delete mechanism that maintains an audit trail.

  The tool enforces referential integrity by preventing deletion of tasks
  that have non-closed child tasks. Tasks can be identified either by exact
  task-id or by fuzzy title-pattern matching.

  Part of the refactored tool architecture where each tool lives in its own
  namespace under mcp-tasks.tool.*, with the main tools.clj acting as a facade."
  (:require
    [cheshire.core :as json]
    [mcp-tasks.schema :as schema]
    [mcp-tasks.tasks :as tasks]
    [mcp-tasks.tools.git :as git]
    [mcp-tasks.tools.helpers :as helpers]
    [mcp-tasks.tools.validation :as validation]))

(defn- delete-task-impl
  "Implementation of delete-task tool.

  Finds a task by exact match (task-id or title-pattern) and marks it as deleted
  with :status :deleted, then moves it to complete.ednl.

  Prevents deletion of parent tasks that have non-closed children.

  At least one of task-id or title-pattern must be provided.
  If both are provided, they must refer to the same task.

  Returns:
  - Git mode enabled: Three text items (deletion message + JSON with deleted task data + JSON with git status)
  - Git mode disabled: Two text items (deletion message + JSON with deleted task data)"
  [config _context {:keys [task-id title-pattern]}]
  ;; Perform file operations inside lock
  (let [locked-result (helpers/with-task-lock config
                                              (fn []
                                                ;; Sync with remote and load tasks
                                                (let [sync-result (helpers/sync-and-prepare-task-file config)]
                                                  (if (and (map? sync-result) (false? (:success sync-result)))
                                                    ;; sync-result is an error map
                                                    (let [{:keys [error error-type]} sync-result
                                                          tasks-dir (:resolved-tasks-dir config)]
                                                      (helpers/build-tool-error-response
                                                        (case error-type
                                                          :conflict (str "Pull failed with conflicts. Resolve manually in " tasks-dir)
                                                          :network (str "Pull failed: " error)
                                                          (str "Pull failed: " error))
                                                        "delete-task"
                                                        {:error-type error-type
                                                         :error-details error
                                                         :tasks-dir tasks-dir}))

                                                    ;; sync-result is the tasks-file path - proceed
                                                    ;; Setup common context and load tasks
                                                    (let [context (helpers/setup-completion-context config "delete-task")]
                                                      (if (:isError context)
                                                        context

                                                        (let [{:keys [tasks-file complete-file]} context
                                                              ;; Find task using shared helper (title-pattern is used for exact match)
                                                              task-result (validation/find-task-by-identifiers task-id title-pattern "delete-task" tasks-file)]

                                                          ;; Check if task-result is an error response
                                                          (if (:isError task-result)
                                                            task-result

                                                            ;; task-result is the actual task - proceed with validations
                                                            (let [task task-result]
                                                              (cond
                                                                ;; Verify task is not already deleted
                                                                (= (:status task) :deleted)
                                                                (helpers/build-tool-error-response
                                                                  "Task is already deleted"
                                                                  "delete-task"
                                                                  {:task-id (:id task)
                                                                   :title (:title task)
                                                                   :file tasks-file})

                                                                ;; Check for non-closed children
                                                                :else
                                                                (let [children (tasks/get-children (:id task))
                                                                      ;; Only open, in-progress, and blocked tasks prevent deletion
                                                                      ;; Closed and deleted tasks are considered resolved
                                                                      non-closed-children (filterv #(schema/blocking-statuses (:status %)) children)]
                                                                  (if (seq non-closed-children)
                                                                    ;; Error: non-closed children exist
                                                                    (helpers/build-tool-error-response
                                                                      "Cannot delete task with children. Delete or complete all child tasks first."
                                                                      "delete-task"
                                                                      {:task-id (:id task)
                                                                       :title (:title task)
                                                                       :child-count (count non-closed-children)
                                                                       :non-closed-children (mapv #(select-keys % [:id :title :status]) non-closed-children)
                                                                       :file tasks-file})

                                                                    ;; All validations passed - delete task
                                                                    (let [{:keys [use-git? tasks-rel-path complete-rel-path base-dir]} context
                                                                          ;; Update task status to :deleted
                                                                          updated-task (assoc task :status :deleted)
                                                                          _ (tasks/update-task (:id task) {:status :deleted})
                                                                          ;; Move to complete.ednl
                                                                          _ (tasks/move-task! (:id task) tasks-file complete-file)]
                                                                      ;; Return intermediate data for git operations
                                                                      {:updated-task updated-task
                                                                       :tasks-rel-path tasks-rel-path
                                                                       :complete-rel-path complete-rel-path
                                                                       :base-dir base-dir
                                                                       :use-git? use-git?})))))))))))))]
    ;; Check if locked section returned an error
    (if (:isError locked-result)
      locked-result

      ;; Perform git operations outside lock
      (let [{:keys [updated-task tasks-rel-path complete-rel-path base-dir use-git?]} locked-result
            msg-text (str "Task " (:id updated-task) " deleted successfully")
            modified-files [tasks-rel-path complete-rel-path]
            git-result (when use-git?
                         (git/commit-task-changes base-dir
                                                  modified-files
                                                  (str "Delete task #" (:id updated-task) ": " (:title updated-task))))]
        ;; Build response with deleted task data
        (if use-git?
          {:content [{:type "text"
                      :text msg-text}
                     {:type "text"
                      :text (json/generate-string {:deleted updated-task
                                                   :metadata {:count 1
                                                              :status "deleted"}})}
                     {:type "text"
                      :text (json/generate-string
                              (cond-> {:git-status (if (:success git-result)
                                                     "success"
                                                     "error")
                                       :git-commit (:commit-sha git-result)}
                                (:error git-result)
                                (assoc :git-error (:error git-result))))}]
           :isError false}
          {:content [{:type "text"
                      :text msg-text}
                     {:type "text"
                      :text (json/generate-string {:deleted updated-task
                                                   :metadata {:count 1
                                                              :status "deleted"}})}]
           :isError false})))))

(defn delete-task-tool
  "Tool to delete a task by marking it :status :deleted and moving to complete.ednl.

  Prevents deletion of parent tasks that have non-closed children.

  Accepts config parameter for future git-aware functionality."
  [config]
  {:name "delete-task"
   :description "Delete a task from tasks.ednl by marking it :status :deleted and moving to complete.ednl. Cannot delete tasks with non-closed children. At least one of task-id or title-pattern must be provided."
   :inputSchema
   {:type "object"
    :properties
    {"task-id"
     {:type "integer"
      :description "Exact task ID to delete"}
     "title-pattern"
     {:type "string"
      :description "Pattern for fuzzy title matching"}}
    :required []}
   :implementation (partial delete-task-impl config)})
(ns mcp-tasks.tool.update-task
  "MCP tool for modifying existing task fields.

  This namespace implements the update-task tool, which allows selective
  field updates on existing tasks. Supports updating any combination of:
  - title, description, design: Text content
  - category, type, status: Enumerated fields
  - parent-id: Task hierarchy (can be set to nil to remove parent)
  - meta: Key-value metadata map (replaces entire map)
  - relations: Task relationships vector (replaces entire vector)

  The tool validates all field values and handles type conversions from
  JSON to EDN formats. Only provided fields are updated; others remain
  unchanged.

  Part of the refactored tool architecture where each tool lives in its own
  namespace under mcp-tasks.tool.*, with the main tools.clj acting as a facade."
  (:require
    [cheshire.core :as json]
    [mcp-tasks.tasks :as tasks]
    [mcp-tasks.tools.git :as git]
    [mcp-tasks.tools.helpers :as helpers]
    [mcp-tasks.tools.validation :as validation]))

(defn- convert-enum-field
  "Convert string enum value to keyword.

  Returns keyword version of the string value."
  [value]
  (keyword value))

(defn- convert-meta-field
  "Convert meta field value, ensuring string keys and values.

  The Task schema requires meta to be [:map-of :string :string].
  This function ensures both keys and values are coerced to strings,
  preventing keywordization from JSON parsing or MCP client libraries.

  Returns {} if value is nil.

  Note: When updating a task's :meta field, the entire map is replaced,
  not merged. This design decision ensures predictable behavior - users
  provide the complete desired state rather than incremental updates.
  This matches the story requirements and simplifies the mental model
  for task updates."
  [value]
  (if value
    (into {} (map (fn [[k v]] [(str k) (str v)]) value))
    {}))

(defn- convert-relations-field
  "Convert relations from JSON structure to Clojure keyword-based structure.

  Transforms string keys to keywords for :as-type field.
  Returns [] if relations is nil.

  Note: When updating a task's :relations field, the entire vector is
  replaced, not appended or merged. This design decision ensures
  predictable behavior - users provide the complete desired state rather
  than incremental updates. This matches the story requirements and
  simplifies the mental model for task updates."
  [relations]
  (if relations
    (mapv (fn [rel]
            {:id (get rel "id")
             :relates-to (get rel "relates-to")
             :as-type (keyword (get rel "as-type"))})
          relations)
    []))

(defn- extract-provided-updates
  "Extract and convert provided fields from arguments map.

  Returns map with only the fields that were actually provided in arguments,
  with appropriate type conversions applied.

  Type conversions:
  - :status, :type - string to keyword
  - :meta - nil becomes {}, replaces entire map (does not merge)
  - :relations - nil becomes [], replaces entire vector (does not append)

  Note: The :meta and :relations fields use replacement semantics rather
  than merge/append. This design ensures predictable behavior where users
  specify the complete desired state in a single update operation."
  [arguments]
  (let [conversions {:status convert-enum-field
                     :type convert-enum-field
                     :meta convert-meta-field
                     :relations convert-relations-field}
        updatable-fields [:title :description :design :parent-id
                          :status :category :type :meta :relations]]
    (reduce (fn [updates field-key]
              (if (contains? arguments field-key)
                (let [value (get arguments field-key)
                      converter (get conversions field-key identity)
                      converted-value (converter value)]
                  (assoc updates field-key converted-value))
                updates))
            {}
            updatable-fields)))

(defn- update-task-impl
  "Implementation of update-task tool.

  Updates specified fields of an existing task in tasks.ednl.
  Supports all mutable task fields with proper nil handling."
  [config _context arguments]
  ;; Perform file operations inside lock
  (let [locked-result (helpers/with-task-lock config
                                              (fn []
                                                ;; Sync with remote and load tasks
                                                (let [sync-result (helpers/sync-and-prepare-task-file config)]
                                                  (if (and (map? sync-result) (false? (:success sync-result)))
                                                    ;; sync-result is an error map
                                                    (let [{:keys [error error-type]} sync-result
                                                          tasks-dir (:resolved-tasks-dir config)]
                                                      (helpers/build-tool-error-response
                                                        (case error-type
                                                          :conflict (str "Pull failed with conflicts. Resolve manually in " tasks-dir)
                                                          :network (str "Pull failed: " error)
                                                          (str "Pull failed: " error))
                                                        "update-task"
                                                        {:error-type error-type
                                                         :error-details error
                                                         :tasks-dir tasks-dir}))

                                                    ;; sync-result is the tasks-file path - proceed
                                                    (let [task-id (:task-id arguments)
                                                          tasks-file sync-result]
                                                      (tasks/load-tasks! tasks-file)
                                                      (let [updates (extract-provided-updates arguments)]
                                                        (if (empty? updates)
                                                          (helpers/build-tool-error-response
                                                            "No fields to update"
                                                            "update-task"
                                                            {:task-id task-id
                                                             :file tasks-file})
                                                          (or (validation/validate-task-exists task-id "update-task" tasks-file)
                                                              (when (and (contains? updates :parent-id) (:parent-id updates))
                                                                (validation/validate-parent-id-exists (:parent-id updates) "update-task" task-id tasks-file "Parent task not found"))
                                                              (let [old-task (tasks/get-task task-id)
                                                                    updated-task (merge old-task updates)]
                                                                (validation/validate-task-schema updated-task "update-task" task-id tasks-file))
                                                              (do
                                                                (tasks/update-task task-id updates)
                                                                (tasks/save-tasks! tasks-file)
                                                                (let [final-task (tasks/get-task task-id)
                                                                      tasks-path (helpers/task-path config ["tasks.ednl"])
                                                                      tasks-rel-path (:relative tasks-path)]
                                                                  ;; Return intermediate data for git operations
                                                                  {:final-task final-task
                                                                   :tasks-file tasks-file
                                                                   :tasks-rel-path tasks-rel-path
                                                                   :task-id task-id}))))))))))]
    ;; Check if locked section returned an error
    (if (:isError locked-result)
      locked-result

      ;; Perform git operations outside lock
      (let [{:keys [final-task tasks-file tasks-rel-path task-id]} locked-result
            use-git? (:use-git? config)
            git-result (when use-git?
                         (let [truncated-title (helpers/truncate-title (:title final-task))]
                           (git/commit-task-changes (:base-dir config)
                                                    [tasks-rel-path]
                                                    (str "Update task #" task-id ": " truncated-title))))
            task-data-json (json/generate-string
                             {:task (select-keys
                                      final-task
                                      [:id :title :category :type :status :parent-id])
                              :metadata {:file tasks-file
                                         :operation "update-task"}})]
        (if use-git?
          {:content [{:type "text"
                      :text (str "Task " task-id " updated in " tasks-file)}
                     {:type "text"
                      :text task-data-json}
                     {:type "text"
                      :text (json/generate-string
                              (cond-> {:git-status (if (:success git-result)
                                                     "success"
                                                     "error")
                                       :git-commit (:commit-sha git-result)}
                                (:error git-result)
                                (assoc :git-error (:error git-result))))}]
           :isError false}
          {:content [{:type "text"
                      :text (str "Task " task-id " updated in " tasks-file)}
                     {:type "text"
                      :text task-data-json}]
           :isError false})))))

(defn update-task-tool
  "Tool to update fields of an existing task.

  Accepts config parameter for future git-aware functionality."
  [config]
  {:name "update-task"
   :description "Update fields of an existing task by ID. Only provided fields will be updated. Supports updating: title, description, design, parent-id, status, category, type, meta, and relations. Pass nil for optional fields (parent-id, meta, relations) to clear their values."
   :inputSchema
   {:type "object"
    :properties
    {"task-id"
     {:type "integer"
      :description "The ID of the task to update"}
     "title"
     {:type "string"
      :description "New title for the task (optional)"}
     "description"
     {:type "string"
      :description "New description for the task (optional)"}
     "design"
     {:type "string"
      :description "New design notes for the task (optional)"}
     "parent-id"
     {:type ["integer" "null"]
      :description "New parent task ID (optional). Pass null to remove parent relationship."}
     "status"
     {:type "string"
      :enum ["open" "closed" "in-progress" "blocked"]
      :description "New task status (optional)"}
     "category"
     {:type "string"
      :description "New task category (optional)"}
     "type"
     {:type "string"
      :enum ["task" "bug" "feature" "story" "chore"]
      :description "New task type (optional)"}
     "meta"
     {:type ["object" "null"]
      :description "New metadata map with string keys and values (optional). Pass null to clear. Replaces entire map, does not merge."}
     "relations"
     {:type ["array" "null"]
      :items {:type "object"
              :properties {"id" {:type "integer"}
                           "relates-to" {:type "integer"}
                           "as-type" {:type "string"
                                      :enum ["blocked-by" "related" "discovered-during"]}}
              :required ["id" "relates-to" "as-type"]}
      :description "New relations vector (optional). Pass null to clear. Replaces entire vector, does not merge."}}
    :required ["task-id"]}
   :implementation (partial update-task-impl config)})
(ns mcp-tasks.response
  "Response formatting utilities for MCP tools.")

(defn error-response
  "Create a standardized error response for MCP tools.

  Takes an exception and returns a map with :content and :isError keys.
  The error message includes the exception message and ex-data details
  if present.

  Parameters:
  - e: Exception to format

  Returns:
  {:content [{:type \"text\" :text \"Error: ...\"}]
   :isError true}"
  [e]
  {:content [{:type "text"
              :text (str "Error: " (ex-message e)
                         (when-let [data (ex-data e)]
                           (str "\nDetails: " (pr-str data))))}]
   :isError true})
(ns mcp-tasks.execution-state
  "Management of current execution state for stories and tasks.
  
  Uses lazy-loading via requiring-resolve and compiled validators with delays
  to avoid loading Malli at namespace load time."
  (:require
    [babashka.fs :as fs]
    [clojure.edn :as edn]))

;; Schema

(def ExecutionState
  "Schema for current execution state.

  Tracks which story and task are currently being executed by the agent."
  [:map
   [:story-id {:optional true} [:maybe :int]]
   [:task-id :int]
   [:started-at :string]])

;; Validation

;; Compiled validators using delays with reader conditionals
;; In Babashka: Malli is opt-in via USE_MALLI environment variable
;; In JVM: Malli is always enabled
;; Both requiring-resolve AND validator compilation happen lazily

(def execution-state-validator
  "Compiled validator for ExecutionState schema."
  #?(:bb (if (System/getenv "USE_MALLI")
           (delay ((requiring-resolve 'malli.core/validator) ExecutionState))
           (delay (fn [_] true)))
     :clj (delay ((requiring-resolve 'malli.core/validator) ExecutionState))))

(def execution-state-explainer
  "Compiled explainer for ExecutionState schema."
  #?(:bb (if (System/getenv "USE_MALLI")
           (delay ((requiring-resolve 'malli.core/explainer) ExecutionState))
           (delay (fn [_] nil)))
     :clj (delay ((requiring-resolve 'malli.core/explainer) ExecutionState))))

(defn valid-execution-state?
  "Validate an execution state map against the ExecutionState schema."
  [state]
  (@execution-state-validator state))

(defn explain-execution-state
  "Explain why an execution state map is invalid.
  Returns nil if valid, explanation map if invalid."
  [state]
  (@execution-state-explainer state))

;; File Path

(defn- state-file-path
  "Returns path to execution state file for the given base directory."
  [base-dir]
  (str base-dir "/.mcp-tasks-current.edn"))

;; Public API

(defn read-execution-state
  "Read current execution state from file.

  Returns execution state map if file exists and is valid, nil otherwise.
  Logs warnings for malformed or invalid state."
  [base-dir]
  (let [file-path (state-file-path base-dir)]
    (when (fs/exists? file-path)
      (try
        (let [state (edn/read-string (slurp file-path))]
          (if (valid-execution-state? state)
            state
            (do
              (binding [*out* *err*]
                (println (format "Warning: Invalid execution state: %s"
                                 (pr-str (explain-execution-state state)))))
              nil)))
        (catch Exception e
          (binding [*out* *err*]
            (println (format "Warning: Failed to read execution state: %s"
                             (.getMessage e))))
          nil)))))

(defn write-execution-state!
  "Write execution state to file atomically.

  Creates parent directories if needed. Validates state before writing.
  Throws ex-info if state is invalid."
  [base-dir state]
  (when-not (valid-execution-state? state)
    (throw (ex-info "Invalid execution state schema"
                    {:state state
                     :explanation (explain-execution-state state)})))
  (let [file-path (state-file-path base-dir)
        temp-file (str file-path ".tmp")]
    (when-let [parent (fs/parent file-path)]
      (fs/create-dirs parent))
    (spit temp-file (pr-str state))
    (fs/move temp-file file-path {:replace-existing true})))

(defn clear-execution-state!
  "Remove the execution state file if it exists.

  Returns true if file was deleted, false if it didn't exist."
  [base-dir]
  (let [file-path (state-file-path base-dir)]
    (when (fs/exists? file-path)
      (fs/delete file-path)
      true)))
(ns mcp-tasks.tool.work-on
  "MCP tool for setting up the environment to work on a task.

  This tool handles the setup steps for task execution, including:
  - Task validation
  - Branch management (if configured)
  - Execution state tracking

  It provides a reusable setup mechanism for both standalone and story tasks,
  making it available for individual task execution, story task execution,
  manual workflow preparation, and external tool integration."
  (:require
    [babashka.fs :as fs]
    [cheshire.core :as json]
    [clojure.string :as str]
    [mcp-clj.log :as log]
    [mcp-tasks.execution-state :as execution-state]
    [mcp-tasks.response :as response]
    [mcp-tasks.tasks :as tasks]
    [mcp-tasks.tools.git :as git]
    [mcp-tasks.tools.helpers :as helpers]
    [mcp-tasks.util :as util]))

(defn- calculate-branch-name
  "Calculate the branch name for a task or story.

  Uses the parent story's title if present, otherwise uses the task's title.
  The title is sanitized using util/sanitize-branch-name with the configured
  word limit (defaults to 4 words).

  Parameters:
  - task: The task being worked on
  - parent-story: The parent story (nil if standalone task)
  - config: Configuration map containing :branch-title-words (optional, defaults to 4)

  Returns:
  - The sanitized branch name string with ID prefix

  Examples:
  (calculate-branch-name {:title \"My Task\" :id 42} nil {:branch-title-words 4})
  ;; => \"42-my-task\"

  (calculate-branch-name
    {:title \"Child Task\" :id 10} {:title \"Parent Story\" :id 5} {:branch-title-words 4})
  ;; => \"5-parent-story\""
  [task parent-story config]
  (let [title (if parent-story
                (:title parent-story)
                (:title task))
        branch-source-id (if parent-story
                           (:id parent-story)
                           (:id task))
        word-limit (get config :branch-title-words 4)]
    (util/sanitize-branch-name title branch-source-id word-limit)))

(defn- calculate-base-branch
  [configured-base-branch main-repo-dir]
  (if configured-base-branch
    ;; Use configured base branch
    (let [branch-check (git/ensure-git-success!
                         (git/branch-exists? main-repo-dir configured-base-branch)
                         (str "branch-exists? " configured-base-branch))]
      (when-not (:exists? branch-check)
        (throw (ex-info (str "Configured base branch " configured-base-branch " does not exist")
                        {:base-branch configured-base-branch
                         :operation "validate-base-branch"})))
      configured-base-branch)
    ;; Auto-detect default branch
    (:branch (git/ensure-git-success!
               (git/get-default-branch main-repo-dir)
               "get-default-branch"))))

(defn- manage-branch
  "Manages git branch for task execution.

  Parameters:
  - base-dir: Base directory (for context-specific operations like checking uncommitted changes)
  - branch-name: The sanitized branch name to use
  - config: Configuration map from read-config (must include :main-repo-dir)

  Uses :main-repo-dir from config for repository-wide branch operations.
  Uses base-dir for context-specific operations in the current directory.

  Returns a map with:
  - :success - boolean indicating if operation succeeded
  - :branch-name - the target branch name
  - :branch-created? - boolean indicating if branch was created
  - :branch-switched? - boolean indicating if branch was switched
  - :error - error message string (or nil if successful)

  Examples:
  ;; Creates new branch
  (manage-branch \"/path\" \"my-story\" config)
  ;; => {:success true :branch-name \"my-story\" :branch-created? true :branch-switched? true}

  ;; Branch exists, switches to it
  (manage-branch \"/path\" \"my-story\" config)
  ;; => {:success true :branch-name \"my-story\" :branch-created? false :branch-switched? true}

  ;; Already on correct branch (no-op case)
  (manage-branch \"/path\" \"my-task\" config)
  ;; => {:success true :branch-name \"my-task\" :branch-created? false :branch-switched? false}"
  [base-dir branch-name config]
  (try
    (let [;; Extract main-repo-dir for repository operations
          main-repo-dir (:main-repo-dir config)

          ;; Get current branch (uses base-dir for current context)
          current-branch (:branch (git/ensure-git-success!
                                    (git/get-current-branch base-dir)
                                    "get-current-branch"))]

      (if (= current-branch branch-name)
        ;; Already on target branch
        {:success true
         :branch-name branch-name
         :branch-created? false
         :branch-switched? false
         :error nil}

        ;; Need to switch branches - check for uncommitted changes first (uses base-dir)
        (if (:has-changes? (git/ensure-git-success!
                             (git/check-uncommitted-changes base-dir)
                             "check-uncommitted-changes"))
          {:success false
           :error (str "Cannot switch branches with uncommitted changes. "
                       "Please commit or stash your changes first.")
           :metadata {:current-branch current-branch
                      :target-branch branch-name}}

          ;; Get base branch (from config or auto-detect, uses main-repo-dir)
          (let [configured-base-branch (:base-branch config)
                base-branch (calculate-base-branch
                              configured-base-branch
                              main-repo-dir)]

            ;; Checkout base branch (uses base-dir for checkout)
            (git/ensure-git-success!
              (git/checkout-branch base-dir base-branch)
              (str "checkout-branch " base-branch))

            ;; Pull latest (ignore errors for local-only repos, uses base-dir)
            (git/pull-latest base-dir base-branch)

            ;; Check if target branch exists (uses main-repo-dir)
            (if (:exists? (git/ensure-git-success!
                            (git/branch-exists? main-repo-dir branch-name)
                            (str "branch-exists? " branch-name)))
              ;; Branch exists, checkout (uses base-dir)
              (do
                (git/ensure-git-success!
                  (git/checkout-branch base-dir branch-name)
                  (str "checkout-branch " branch-name))
                {:success true
                 :branch-name branch-name
                 :branch-created? false
                 :branch-switched? true
                 :error nil})

              ;; Branch doesn't exist, create and checkout (uses base-dir)
              (do
                (git/ensure-git-success!
                  (git/create-and-checkout-branch base-dir branch-name)
                  (str "create-and-checkout-branch " branch-name))
                {:success true
                 :branch-name branch-name
                 :branch-created? true
                 :branch-switched? true
                 :error nil}))))))

    (catch clojure.lang.ExceptionInfo e
      {:success false
       :error (:error (ex-data e) (.getMessage e))
       :metadata (dissoc (ex-data e) :error)})))

(defn- extract-worktree-name
  "Extract the worktree name from a worktree path.

  Returns the final path component (directory name).

  Example: /Users/duncan/projects/mcp-tasks-fix-bug/ -> mcp-tasks-fix-bug"
  [worktree-path]
  (when worktree-path
    (fs/file-name worktree-path)))

(defn- current-working-directory
  "Get the current working directory as a canonical path.

  Extracted into a separate function to allow mocking in tests."
  []
  (fs/canonicalize (System/getProperty "user.dir")))

(defn- in-worktree?
  "Check if the current directory is inside the specified worktree path.

  Compares canonical paths to handle symlinks and relative paths correctly."
  [current-dir worktree-path]
  (when worktree-path
    (let [worktree-canonical (fs/canonicalize worktree-path)]
      (= current-dir worktree-canonical))))

(defn- worktree-needs-creation?
  "Check if a worktree needs to be created (doesn't exist yet)."
  [worktree-exists?]
  (not worktree-exists?))

(defn- worktree-needs-switch?
  "Check if we need to switch to an existing worktree.
   If the worktree exists but we're not in it,"
  [worktree-exists? current-dir worktree-path]
  (and worktree-exists?
       (not (in-worktree? current-dir worktree-path))))

(defn- worktree-switch-message
  "Create a user-facing message for worktree directory switch.

  Parameters:
  - status: Either :created or :exists
  - worktree-path: Path to the worktree

  Returns:
  - String message instructing user to switch to the worktree directory"
  [status worktree-path]
  (str "Worktree "
       (case status
         :created "created"
         :exists "exists")
       " at "
       worktree-path
       ". Please start a new Claude Code session in that directory."))

(defn- manage-worktree
  "Manages git worktree for task execution.

  Parameters:
  - base-dir: Base directory (current working directory, may be a worktree)
  - title: The title to use for deriving the worktree path
  - task-id: The task or story ID number (used for worktree path generation)
  - branch-name: The sanitized branch name to use
  - config: Configuration map from read-config (must include :main-repo-dir)

  Uses :main-repo-dir from config for repository-wide worktree operations.
  Uses base-dir for context-specific operations in the current directory.

  Returns a map with:
  - :success - boolean indicating if operation succeeded
  - :worktree-path - path to the worktree
  - :worktree-created? - boolean indicating if worktree was created
  - :needs-directory-switch? - boolean indicating if user needs to switch directories
  - :branch-name - the branch name for the worktree
  - :clean? - boolean indicating if worktree has no uncommitted changes (nil if not in worktree)
  - :error - error message string (or nil if successful)
  - :message - user-facing message about required actions

  Examples:
  ;; Worktree doesn't exist, needs creation
  (manage-worktree \"/path\" \"Fix Bug\" 123 \"123-fix-bug\" config)
  ;; => {:success true :worktree-path \"../mcp-tasks-123-fix-bug\" :worktree-created? true
  ;;     :needs-directory-switch? true :branch-name \"123-fix-bug\" :clean? nil
  ;;     :message \"Worktree created at ../mcp-tasks-123-fix-bug. Please start a new Claude Code session in that directory.\"}

  ;; Worktree exists but not in it
  (manage-worktree \"/path\" \"Fix Bug\" 123 \"123-fix-bug\" config)
  ;; => {:success true :worktree-path \"../mcp-tasks-123-fix-bug\" :worktree-created? false
  ;;     :needs-directory-switch? true :branch-name \"123-fix-bug\" :clean? nil
  ;;     :message \"Worktree exists at ../mcp-tasks-123-fix-bug. Please start a new Claude Code session in that directory.\"}

  ;; In worktree, correct branch, clean
  (manage-worktree \"/path\" \"Fix Bug\" 123 \"123-fix-bug\" config)
  ;; => {:success true :worktree-path \"/path\" :worktree-created? false
  ;;     :needs-directory-switch? false :branch-name \"123-fix-bug\" :clean? true}

  ;; In worktree, correct branch, dirty
  (manage-worktree \"/path\" \"Fix Bug\" 123 \"123-fix-bug\" config)
  ;; => {:success true :worktree-path \"/path\" :worktree-created? false
  ;;     :needs-directory-switch? false :branch-name \"123-fix-bug\" :clean? false}

  ;; In worktree, wrong branch (error)
  (manage-worktree \"/path\" \"Fix Bug\" 123 \"other-branch\" config)
  ;; => {:success false :error \"Worktree is on branch 'other' but expected '123-fix-bug'\"}"
  [_base-dir title task-id branch-name config]
  (try
    (let [;; Extract main-repo-dir for worktree operations
          main-repo-dir (:main-repo-dir config)

          ;; Get current working directory (canonical path)
          current-dir (current-working-directory)

          ;; Check if branch already exists in any worktree (uses main-repo-dir)
          find-result (git/ensure-git-success!
                        (git/find-worktree-for-branch main-repo-dir branch-name)
                        "find-worktree-for-branch")
          existing-worktree (:worktree find-result)]

      (if existing-worktree
        ;; Branch exists in a worktree - use that worktree
        (let [worktree-path (:path existing-worktree)]
          (if (in-worktree? current-dir worktree-path)
            ;; Already in the correct worktree - check if clean
            (let [is-clean? (-> (git/check-uncommitted-changes worktree-path)
                                (git/ensure-git-success!
                                  "check-uncommitted-changes")
                                :has-changes?
                                not)]
              {:success true
               :worktree-path worktree-path
               :worktree-created? false
               :needs-directory-switch? false
               :branch-name branch-name
               :clean? is-clean?
               :error nil})

            ;; Need to switch to existing worktree
            {:success true
             :worktree-path worktree-path
             :worktree-created? false
             :needs-directory-switch? true
             :branch-name branch-name
             :clean? nil
             :error nil
             :message (worktree-switch-message :exists worktree-path)}))

        ;; Branch not in any worktree - proceed with deriving path and
        ;; creating/checking worktree
        (let [;; Derive worktree path (uses main-repo-dir)
              path-result (git/ensure-git-success!
                            (git/derive-worktree-path main-repo-dir title task-id config)
                            "derive-worktree-path")
              worktree-path (:path path-result)

              ;; Check if worktree exists at the derived path (uses main-repo-dir)
              exists-result (git/ensure-git-success!
                              (git/worktree-exists? main-repo-dir worktree-path)
                              "worktree-exists?")
              worktree-exists? (:exists? exists-result)
              branch-exists? (:exists? (git/ensure-git-success!
                                         (git/branch-exists? main-repo-dir branch-name)
                                         "branch-exists?"))]

          (cond
            ;; Worktree doesn't exist - create it (uses main-repo-dir)
            (worktree-needs-creation? worktree-exists?)
            (do
              (git/ensure-git-success!
                (git/create-worktree
                  main-repo-dir
                  worktree-path
                  branch-name
                  (when-not branch-exists?
                    (calculate-base-branch
                      (:base-branch config)
                      main-repo-dir)))
                (str "create-worktree " worktree-path " " branch-name))
              {:success true
               :worktree-path worktree-path
               :worktree-created? true
               :needs-directory-switch? true
               :branch-name branch-name
               :clean? nil
               :error nil
               :message (worktree-switch-message :created worktree-path)})

            ;; Worktree exists but we're not in it
            (worktree-needs-switch? worktree-exists? current-dir worktree-path)
            {:success true
             :worktree-path worktree-path
             :worktree-created? false
             :needs-directory-switch? true
             :branch-name branch-name
             :clean? nil
             :error nil
             :message (worktree-switch-message :exists worktree-path)}

            ;; We're in the worktree - verify branch and check clean status
            :else
            (let [current-branch (-> (git/worktree-branch worktree-path)
                                     (git/ensure-git-success! "worktree-branch")
                                     :branch)]

              ;; Verify we're on the correct branch
              (when (not= current-branch branch-name)
                (throw
                  (ex-info
                    (str "Worktree is on branch " current-branch " but expected " branch-name)
                    {:current-branch current-branch
                     :expected-branch branch-name
                     :worktree-path worktree-path
                     :operation "verify-worktree-branch"})))

              ;; Check if worktree is clean
              (let [is-clean? (-> (git/check-uncommitted-changes worktree-path)
                                  (git/ensure-git-success! "check-uncommitted-changes")
                                  :has-changes?
                                  not)]
                {:success true
                 :worktree-path worktree-path
                 :worktree-created? false
                 :needs-directory-switch? false
                 :branch-name branch-name
                 :clean? is-clean?
                 :error nil}))))))

    (catch clojure.lang.ExceptionInfo e
      {:success false
       :error (:error (ex-data e) (.getMessage e))
       :metadata (dissoc (ex-data e) :error)})))

(defn- safe-to-remove-worktree?
  "Checks if a worktree is safe to remove.

  Performs safety checks to ensure no work will be lost:
  1. Verifies no uncommitted changes exist
  2. Verifies all commits are pushed to remote

  Parameters:
  - worktree-path: Path to the worktree to check

  Returns a map with:
  - :safe? - boolean indicating if safe to remove
  - :reason - string describing the result

  Examples:
  ;; Safe to remove
  {:safe? true :reason \"Worktree is clean and all commits are pushed\"}

  ;; Not safe - uncommitted changes
  {:safe? false :reason \"Uncommitted changes exist in worktree\"}

  ;; Not safe - unpushed commits
  {:safe? false :reason \"Unpushed commits exist\"}"
  [worktree-path]
  {:pre [(string? worktree-path)
         (not (str/blank? worktree-path))]}
  (let [uncommitted-result (git/check-uncommitted-changes worktree-path)
        pushed-result (git/check-all-pushed? worktree-path)
        result (or
                 ;; Return first failure found, or nil to continue to success case
                 (when-not (:success uncommitted-result)
                   {:safe? false
                    :reason (str "Failed to check uncommitted changes: " (:error uncommitted-result))})

                 (when (:has-changes? uncommitted-result)
                   {:safe? false
                    :reason "Uncommitted changes exist in worktree"})

                 (when-not (:success pushed-result)
                   {:safe? false
                    :reason (:reason pushed-result)})

                 (when-not (:all-pushed? pushed-result)
                   {:safe? false
                    :reason (:reason pushed-result)})

                 ;; All checks passed
                 {:safe? true
                  :reason "Worktree is clean and all commits are pushed"})]
    (log/info :worktree-safety-check
              {:worktree-path worktree-path
               :safe? (:safe? result)
               :reason (:reason result)})
    result))

(defn cleanup-worktree-after-completion
  "Removes a worktree after verifying it is safe to remove.

  This function should be called after task completion to clean up
  worktrees that were created for task isolation. It performs safety
  checks before removal to prevent data loss.

  Parameters:
  - main-repo-dir: Path to the main repository directory
  - worktree-path: Path to the worktree to remove
  - config: Configuration map (reserved for future use)

  Returns a map with:
  - :success - boolean indicating if removal succeeded
  - :message - string describing success (or nil on failure)
  - :error - string describing failure (or nil on success)

  Examples:
  ;; Successful removal
  {:success true
   :message \"Worktree removed at /path/to/worktree\"
   :error nil}

  ;; Failed safety checks
  {:success false
   :message nil
   :error \"Cannot remove worktree: Uncommitted changes exist in worktree\"}

  ;; Failed removal operation
  {:success false
   :message nil
   :error \"Failed to remove worktree: <git error>\"}"
  [main-repo-dir worktree-path config]
  {:pre [(string? main-repo-dir)
         (not (str/blank? main-repo-dir))
         (string? worktree-path)
         (not (str/blank? worktree-path))
         (map? config)]}
  (let [safety-check (safe-to-remove-worktree? worktree-path)]
    (log/info :worktree-cleanup-attempt
              {:main-repo-dir main-repo-dir
               :worktree-path worktree-path
               :safe-to-remove? (:safe? safety-check)})
    (if (:safe? safety-check)
      ;; Safe to remove - attempt removal
      (let [remove-result (git/remove-worktree main-repo-dir worktree-path)]
        (if (:success remove-result)
          (do
            (log/info :worktree-cleanup-success
                      {:worktree-path worktree-path})
            {:success true
             :message (str "Worktree removed at " worktree-path)
             :error nil})
          (do
            (log/warn :worktree-cleanup-failed
                      {:worktree-path worktree-path
                       :error (:error remove-result)})
            {:success false
             :message nil
             :error (str "Failed to remove worktree: " (:error remove-result))})))
      ;; Not safe to remove
      (do
        (log/warn :worktree-cleanup-skipped
                  {:worktree-path worktree-path
                   :reason (:reason safety-check)})
        {:success false
         :message nil
         :error (str "Cannot remove worktree: " (:reason safety-check))}))))

(defn- validate-task-id-param
  "Validates the task-id parameter.

  Parameters:
  - task-id: The task ID to validate (can be any type)

  Returns:
  - task-id if valid

  Throws:
  - ExceptionInfo with :response key if validation fails"
  [task-id]
  (when-not task-id
    (throw (ex-info "Missing required parameter"
                    {:response {:error "task-id parameter is required"
                                :metadata {}}})))

  (when-not (integer? task-id)
    (throw (ex-info "Invalid parameter type"
                    {:response {:error "task-id must be an integer"
                                :metadata {:provided-value task-id
                                           :provided-type (str (type task-id))}}})))
  task-id)

(defn- have-task!
  [task task-id tasks-file]
  (when-not task
    (throw
      (ex-info
        "Task not found"
        {:response {:error "No task found with the specified task-id"
                    :metadata {:task-id task-id
                               :file tasks-file}}}))))

(defn- have-story!
  [story task-id parent-id tasks-file]
  (when-not story
    (throw
      (ex-info
        "Parent story not found"
        {:response
         {:error "Task references a parent story that does not exist"
          :metadata {:task-id task-id
                     :parent-id parent-id
                     :file tasks-file}}}))))

(defn- load-task-and-story
  "Loads and validates a task and its optional parent story.

  Parameters:
  - cfg: Configuration map
  - task-id: The task ID to load

  Returns:
  - Map with :task and :parent-story keys (parent-story is nil if not a story task)

  Throws:
  - ExceptionInfo with :response key if task or parent story not found"
  [cfg task-id]
  (let [tasks-path (helpers/task-path cfg ["tasks.ednl"])
        tasks-file (:absolute tasks-path)
        complete-path (helpers/task-path cfg ["complete.ednl"])
        complete-file (:absolute complete-path)]

    ;; Load tasks from EDNL file
    (when (helpers/file-exists? tasks-file)
      (tasks/load-tasks! tasks-file :complete-file complete-file))

    ;; Get the specific task
    (let [matching-tasks (tasks/get-tasks :task-id task-id)
          task (first matching-tasks)]
      ;; Validate task exists
      (have-task! task task-id tasks-file)

      ;; Get parent story if this is a story task
      (let [parent-story (when-let [parent-id (:parent-id task)]
                           (let [story (first
                                         (tasks/get-tasks :task-id parent-id))]
                             ;; Validate parent story exists
                             (have-story! story task-id parent-id tasks-file)
                             story))]
        {:task task
         :parent-story parent-story}))))

(defn- build-success-response
  "Builds a success response for the work-on tool.

  Parameters:
  - task: The task being worked on
  - branch-info: Optional branch management result (nil if not enabled)
  - worktree-info: Optional worktree management result (nil if not enabled)
  - state-file-path: Path to the execution state file

  Returns:
  - MCP response map with :content and :isError keys"
  [task branch-info worktree-info state-file-path]
  (let [response-data (cond-> {:task-id (:id task)
                               :title (:title task)
                               :category (:category task)
                               :type (:type task)
                               :status (:status task)
                               :execution-state-file state-file-path
                               :message "Task validated successfully and execution state written"}
                        branch-info
                        (assoc :branch-name (:branch-name branch-info)
                               :branch-created? (:branch-created? branch-info)
                               :branch-switched? (:branch-switched? branch-info))

                        worktree-info
                        (merge {:worktree-path (:worktree-path worktree-info)
                                :worktree-created? (:worktree-created? worktree-info)
                                :worktree-clean? (:clean? worktree-info)}
                               (when-let [wt-path (:worktree-path worktree-info)]
                                 {:worktree-name (extract-worktree-name wt-path)})))]
    {:content [{:type "text"
                :text (json/generate-string response-data)}]
     :isError false}))

(defn- work-on-impl
  "Implementation of work-on tool.

  Validates that the specified task exists, optionally manages branches,
  writes execution state, and returns task details.

  Parameters:
  - task-id (required, integer): The ID of the task to work on

  Returns JSON-encoded response with:
  - Task details (id, title, category, type, status)
  - Branch information (if branch management enabled)
  - Execution state file path
  - Success indicator

  Writes execution state to .mcp-tasks-current.edn with:
  - task-id: The task being worked on
  - story-id: The parent story ID if this is a story task, nil otherwise
  - started-at: ISO-8601 timestamp when work started"
  [cfg _context {:keys [task-id]}]
  (try
    ;; Validate parameters
    (validate-task-id-param task-id)

    ;; Load task, story, config, and setup base directory
    (let [{:keys [task parent-story]} (load-task-and-story cfg task-id)

          base-dir (:base-dir cfg)
          worktree-mgmt-enabled? (:worktree-management? cfg)
          branch-mgmt-enabled? (or worktree-mgmt-enabled?
                                   (:branch-management? cfg))

          ;; Calculate branch name, title, and ID once for use in branch/worktree
          ;; management
          title (if parent-story
                  (:title parent-story)
                  (:title task))
          branch-source-id (if parent-story
                             (:id parent-story)
                             (:id task))
          branch-name (calculate-branch-name task parent-story cfg)

          ;; Handle worktree management if configured
          worktree-info (when worktree-mgmt-enabled?
                          (let [worktree-result (manage-worktree
                                                  base-dir
                                                  title
                                                  branch-source-id
                                                  branch-name
                                                  cfg)]
                            (when-not (:success worktree-result)
                              (throw
                                (ex-info
                                  "Worktree management failed"
                                  {:response
                                   {:error (:error worktree-result)
                                    :metadata (:metadata worktree-result {})}})))
                            worktree-result))

          ;; Handle branch management if configured
          branch-info (when (and branch-mgmt-enabled?
                                 (not worktree-mgmt-enabled?))
                        (let [branch-result (manage-branch
                                              base-dir
                                              branch-name
                                              cfg)]
                          (when-not (:success branch-result)
                            (throw
                              (ex-info
                                "Branch management failed"
                                {:response
                                 {:error (:error branch-result)
                                  :metadata (:metadata branch-result {})}})))
                          branch-result))]

      ;; If worktree management requires directory switch, return early with message
      (if (and worktree-info (:needs-directory-switch? worktree-info))
        (let [worktree-path (:worktree-path worktree-info)
              response-data (cond-> {:task-id (:id task)
                                     :title (:title task)
                                     :category (:category task)
                                     :type (:type task)
                                     :status (:status task)
                                     :worktree-path (str worktree-path)
                                     :worktree-created? (:worktree-created? worktree-info)
                                     :branch-name (:branch-name worktree-info)
                                     :message (:message worktree-info)}
                              worktree-path
                              (assoc :worktree-name (extract-worktree-name worktree-path)))]
          {:content [{:type "text"
                      :text (json/generate-string response-data)}]
           :isError false})

        ;; Otherwise proceed with execution state and normal response
        (let [story-id (:parent-id task)
              started-at (java.time.Instant/now)
              state {:task-id task-id
                     :story-id story-id
                     :started-at (str started-at)}
              _ (execution-state/write-execution-state! base-dir state)
              state-file-path (str base-dir "/.mcp-tasks-current.edn")]
          (build-success-response task branch-info worktree-info state-file-path))))

    (catch clojure.lang.ExceptionInfo e
      ;; Handle validation errors with structured response
      (if-let [response-data (:response (ex-data e))]
        {:content [{:type "text"
                    :text (json/generate-string response-data)}]
         :isError false}
        (response/error-response e)))

    (catch Exception e
      (response/error-response e))))

(defn work-on-tool
  "Tool to set up the environment for working on a task.

  This tool prepares the development environment for task execution by:
  - Validating the task exists
  - Managing git branches (if configured)
  - Setting execution state

  Parameters:
  - task-id (required, integer): The ID of the task to work on

  Returns JSON-encoded response:
  Success: {\"task-id\": N, \"title\": \"...\", \"category\": \"...\", ...}
  Error: {\"error\": \"...\", \"metadata\": {...}}"
  [config]
  {:name "work-on"
   :description "Set up the environment for working on a task"
   :inputSchema
   {:type "object"
    :properties
    {"task-id"
     {:type "integer"
      :description "The ID of the task to work on"}}
    :required ["task-id"]}
   :implementation (partial work-on-impl config)})
(ns mcp-tasks.tool.complete-task
  "MCP tool for marking tasks as complete and archiving them.

  This namespace implements the complete-task tool, which handles the full
  lifecycle of task completion including:
  - Finding tasks by ID or title match
  - Appending optional completion comments
  - Moving tasks from tasks.ednl to complete.ednl with :status :closed
  - Handling special cases for story tasks and child tasks
  - Committing changes to git
  - Cleaning up worktrees when worktree management is enabled

  The tool supports three completion modes:
  - Regular tasks: Simple completion and archive
  - Child tasks: Completion with parent relationship preservation
  - Story tasks: Completion with archival of all child tasks

  Part of the refactored tool architecture where each tool lives in its own
  namespace under mcp-tasks.tool.*, with the main tools.clj acting as a facade."
  (:require
    [mcp-tasks.execution-state :as exec-state]
    [mcp-tasks.schema :as schema]
    [mcp-tasks.tasks :as tasks]
    [mcp-tasks.tool.work-on :as work-on]
    [mcp-tasks.tools.git :as git]
    [mcp-tasks.tools.helpers :as helpers]
    [mcp-tasks.tools.validation :as validation]))

(defn- build-completion-result-base
  "Builds the common base result map returned by completion functions.
  
  All completion functions return similar intermediate data maps for git
  operations and response building. This helper extracts the common fields.
  
  Parameters:
  - config: Configuration map (provides :base-dir)
  - context: Context map (provides :use-git?)
  - task: Task map being completed (for commit message)
  - modified-files: Vector of relative file paths that were modified
  
  Returns base map with:
  - :use-git? - Whether git operations should be performed
  - :base-dir - Base directory for git operations
  - :commit-msg - Commit message for the completion
  - :modified-files - Files to stage in git commit"
  [config context task modified-files]
  {:use-git? (:use-git? context)
   :base-dir (:base-dir config)
   :commit-msg (str "Complete task #" (:id task) ": " (:title task))
   :modified-files modified-files})

(defn- format-regular-task-completion-message
  "Formats completion message for regular tasks.
  
  Parameters:
  - task-id: Task ID
  - complete-file: Path to complete.ednl
  
  Returns: Message string"
  [task-id complete-file]
  (str "Task " task-id " completed and moved to " complete-file))

(defn- format-child-task-completion-message
  "Formats completion message for story child tasks.
  
  Parameters:
  - task-id: Task ID
  
  Returns: Message string"
  [task-id]
  (str "Task " task-id " completed (staying in worktree for remaining story tasks)"))

(defn- format-story-task-completion-message
  "Formats completion message for story tasks.
  
  Parameters:
  - task-id: Story task ID
  - child-count: Number of child tasks archived with the story
  
  Returns: Message string"
  [task-id child-count]
  (str "Story " task-id " completed and archived"
       (when (pos? child-count)
         (str " with " child-count " child task"
              (when (> child-count 1) "s")))))

(defn- complete-regular-task-
  "Completes a regular task by marking it :status :closed and moving to complete.ednl.
  
  Parameters:
  - config: Configuration map
  - context: Context map from setup-completion-context
  - task: Task map to complete
  - completion-comment: Optional comment to append to task description
  
  Returns intermediate data map for git operations and response building."
  [config context task completion-comment]
  (let [{:keys [tasks-file complete-file tasks-rel-path complete-rel-path]} context]
    (tasks/mark-complete (:id task) completion-comment)
    ;; Get the updated task after marking complete
    (let [updated-task (tasks/get-task (:id task))]
      (tasks/move-task! (:id task) tasks-file complete-file)
      ;; Clear execution state after successful completion
      (exec-state/clear-execution-state! (:base-dir config))

      ;; Return intermediate data for git operations
      (merge (build-completion-result-base config context task [tasks-rel-path complete-rel-path])
             {:updated-task updated-task
              :complete-file complete-file
              :msg-text (format-regular-task-completion-message (:id task) complete-file)}))))

(defn- complete-child-task-
  "Completes a story child task by marking it :status :closed but keeping it in tasks.ednl.
  
  Parameters:
  - config: Configuration map
  - context: Context map from setup-completion-context
  - task: Task map to complete (must have :parent-id)
  - completion-comment: Optional comment to append to task description
  
  Returns either:
  - Error response if parent validation fails
  - Intermediate data map for git operations and response building"
  [config context task completion-comment]
  (let [{:keys [tasks-file tasks-rel-path]} context
        parent (tasks/get-task (:parent-id task))]
    (cond
      (not parent)
      (helpers/build-tool-error-response
        "Parent task not found"
        "complete-task"
        {:task-id (:id task)
         :parent-id (:parent-id task)
         :file tasks-file})

      (not= (:type parent) :story)
      (helpers/build-tool-error-response
        "Parent task is not a story"
        "complete-task"
        {:task-id (:id task)
         :parent-id (:parent-id task)
         :parent-type (:type parent)
         :file tasks-file})

      :else
      (do
        (tasks/mark-complete (:id task) completion-comment)
        ;; Get the updated task after marking complete
        (let [updated-task (tasks/get-task (:id task))]
          (tasks/save-tasks! tasks-file)
          ;; Clear execution state after successful completion
          (exec-state/clear-execution-state! (:base-dir config))

          ;; Return intermediate data for git operations
          (merge (build-completion-result-base config context task [tasks-rel-path])
                 {:updated-task updated-task
                  :tasks-file tasks-file
                  :msg-text (format-child-task-completion-message (:id task))
                  :parent-id (:parent-id task)}))))))

(defn- complete-story-task-
  "Completes a story by validating all children are :status :closed, then atomically
  archiving the story and all its children to complete.ednl.
  
  Parameters:
  - config: Configuration map
  - context: Context map from setup-completion-context
  - task: Story task map to complete (must have :type :story)
  - completion-comment: Optional comment to append to task description
  
  Returns either:
  - Error response if children are not all closed
  - Intermediate data map for git operations and response building"
  [config context task completion-comment]
  (let [{:keys [tasks-file complete-file tasks-rel-path complete-rel-path]} context
        children (tasks/get-children (:id task))
        ;; Only open, in-progress, and blocked tasks prevent completion
        ;; Closed and deleted tasks are considered resolved
        blocking-children (filterv #(schema/blocking-statuses (:status %)) children)]
    (if (seq blocking-children)
      ;; Error: unclosed children exist
      (helpers/build-tool-error-response
        (str "Cannot complete story: " (count blocking-children)
             " child task" (when (> (count blocking-children) 1) "s")
             " still " (if (= 1 (count blocking-children)) "is" "are")
             " not closed")
        "complete-task"
        {:task-id (:id task)
         :title (:title task)
         :blocking-children (mapv #(select-keys % [:id :title :status]) blocking-children)
         :file tasks-file})

      ;; All children closed - proceed with atomic archival
      (do
        ;; Mark story as complete in memory
        (tasks/mark-complete (:id task) completion-comment)

        ;; Get updated story BEFORE moving (since move-tasks! removes from memory)
        (let [updated-story (tasks/get-task (:id task))
              all-ids (cons (:id task) (mapv :id children))
              child-count (count children)]
          ;; Move story and all children to complete.ednl atomically
          (tasks/move-tasks! all-ids tasks-file complete-file)
          ;; Clear execution state after successful completion
          (exec-state/clear-execution-state! (:base-dir config))

          ;; Return intermediate data for git operations
          (merge (build-completion-result-base config context task [tasks-rel-path complete-rel-path])
                 {:updated-story updated-story
                  :complete-file complete-file
                  :child-count child-count
                  ;; Override commit-msg to include child count
                  :commit-msg (str "Complete story #" (:id task) ": " (:title task)
                                   (when (pos? child-count)
                                     (str " (with " child-count " task"
                                          (when (> child-count 1) "s") ")")))
                  :msg-text (format-story-task-completion-message (:id task) child-count)}))))))

(defn- build-cleanup-warning
  "Builds a warning message for failed worktree cleanup.

  Parameters:
  - worktree-path: Path to the worktree that failed to be cleaned up
  - error: Error message describing why cleanup failed

  Returns: Warning message string

  Example:
  (build-cleanup-warning \"/path/to/worktree\" \"Uncommitted changes\")
  => \"Warning: Could not remove worktree at /path/to/worktree: Uncommitted changes\""
  [worktree-path error]
  (str "Warning: Could not remove worktree at " worktree-path ": " error))

(defn- enhance-message-with-worktree-cleanup
  "Enhances a completion message with worktree cleanup status.

  Parameters:
  - base-message: The original completion message
  - cleanup-result: Result map from cleanup-worktree-after-completion (or nil)
  - worktree-path: Path to the worktree that was cleaned up

  Returns: Enhanced message string

  Examples:
  ;; No cleanup performed
  (enhance-message-with-worktree-cleanup \"Task completed\" nil \"/path\")
  => \"Task completed\"

  ;; Successful cleanup
  (enhance-message-with-worktree-cleanup 
    \"Task completed\"
    {:success true :message \"Worktree removed\"}
    \"/path/to/worktree\")
  => \"Task completed. Worktree removed at /path/to/worktree (switch directories to continue)\"

  ;; Failed cleanup
  (enhance-message-with-worktree-cleanup
    \"Task completed\"
    {:success false :error \"Uncommitted changes\"}
    \"/path/to/worktree\")
  => \"Task completed. Warning: Could not remove worktree at /path/to/worktree: Uncommitted changes\""
  [base-message cleanup-result worktree-path]
  (if cleanup-result
    (if (:success cleanup-result)
      (str base-message ". Worktree removed at " worktree-path
           " (switch directories to continue)")
      (str base-message ". " (build-cleanup-warning worktree-path (:error cleanup-result))))
    base-message))

(defn- get-current-directory
  "Returns the current working directory for worktree detection purposes.
  
  This is the directory that will be checked to determine if we're running
  from within a worktree. Normally returns (:base-dir config), but can be
  redef'd in tests to simulate running from within a specific worktree.
  
  Parameters:
  - config: Configuration map containing :base-dir
  
  Returns: The directory path string to use for worktree detection"
  [config]
  (:base-dir config))

(defn- complete-task-impl
  "Implementation of complete-task tool.

  Finds a task by exact match (task-id or title) and completes it with optional
  completion comment. Behavior depends on task type:

  - Regular tasks (no parent-id): Marked :status :closed and moved to complete.ednl
  - Story children (has parent-id): Marked :status :closed but stay in tasks.ednl
  - Stories (type :story): Validates all children :status :closed, then atomically
    archives story and all children to complete.ednl

  At least one of task-id or title must be provided.
  If both are provided, they must refer to the same task.

  Returns:
  - Git mode enabled: Three text items (completion message + JSON with :modified-files + JSON with git status)
  - Git mode disabled: Single text item (completion message only)"
  [config _context {:keys [task-id title completion-comment category]}]
  ;; Detect worktree context before lock
  (let [_base-dir (:base-dir config)
        current-dir (get-current-directory config)
        in-worktree? (git/in-worktree? current-dir)
        worktree-path (when in-worktree? current-dir)
        main-repo-dir (when in-worktree? (git/get-main-repo-dir current-dir))

        ;; Perform file operations inside lock
        locked-result (helpers/with-task-lock config
                                              (fn []
                                                ;; Sync with remote and load tasks
                                                (let [sync-result (helpers/sync-and-prepare-task-file config)]
                                                  (if (and (map? sync-result) (false? (:success sync-result)))
                                                    ;; sync-result is an error map
                                                    (let [{:keys [error error-type]} sync-result
                                                          tasks-dir (:resolved-tasks-dir config)]
                                                      (helpers/build-tool-error-response
                                                        (case error-type
                                                          :conflict (str "Pull failed with conflicts. Resolve manually in " tasks-dir)
                                                          :network (str "Pull failed: " error)
                                                          (str "Pull failed: " error))
                                                        "complete-task"
                                                        {:error-type error-type
                                                         :error-details error
                                                         :tasks-dir tasks-dir}))

                                                    ;; sync-result is the tasks-file path - proceed
                                                    (let [context (helpers/setup-completion-context config "complete-task")]
                                                      (if (:isError context)
                                                        context

                                                        (let [{:keys [tasks-file]} context
                                                              ;; Find task using shared helper
                                                              task-result (validation/find-task-by-identifiers task-id title "complete-task" tasks-file)]

                                                          ;; Check if task-result is an error response
                                                          (if (:isError task-result)
                                                            task-result

                                                            ;; task-result is the actual task - proceed with validations
                                                            (let [task task-result]
                                                              ;; Verify category if provided (for backwards compatibility)
                                                              (cond
                                                                (and category (not= (:category task) category))
                                                                (helpers/build-tool-error-response
                                                                  "Task category does not match"
                                                                  "complete-task"
                                                                  {:expected-category category
                                                                   :actual-category (:category task)
                                                                   :task-id (:id task)
                                                                   :file tasks-file})

                                                                ;; Verify task is not already closed
                                                                (= (:status task) :closed)
                                                                (helpers/build-tool-error-response
                                                                  "Task is already closed"
                                                                  "complete-task"
                                                                  {:task-id (:id task)
                                                                   :title (:title task)
                                                                   :file tasks-file})

                                                                ;; All validations passed - dispatch to appropriate completion function
                                                                (= (:type task) :story)
                                                                (complete-story-task- config context task completion-comment)

                                                                (some? (:parent-id task))
                                                                (complete-child-task- config context task completion-comment)

                                                                :else
                                                                (complete-regular-task- config context task completion-comment)))))))))))]
    ;; Check if locked section returned an error
    (if (:isError locked-result)
      locked-result

      ;; Perform git operations and worktree cleanup outside lock
      (let [{:keys [updated-task updated-story tasks-file complete-file modified-files
                    use-git? base-dir commit-msg msg-text child-count parent-id]} locked-result
            git-result (when use-git?
                         (git/commit-task-changes base-dir modified-files commit-msg))

            ;; Attempt worktree cleanup if applicable (skip for child tasks)
            worktree-cleanup-result
            (when (and in-worktree?
                       (:worktree-management? config)
                       (nil? parent-id))
              (work-on/cleanup-worktree-after-completion
                main-repo-dir worktree-path config))

            ;; Enhance message with cleanup status
            enhanced-msg-text (enhance-message-with-worktree-cleanup
                                msg-text worktree-cleanup-result worktree-path)

            ;; Use updated-task for regular/child tasks, updated-story for stories
            final-task (or updated-task updated-story)
            ;; Use tasks-file or complete-file depending on completion type
            metadata-file (or complete-file tasks-file)
            task-data {:task (select-keys final-task [:id :title :description :category :type :status :parent-id])
                       :metadata (cond-> {:file metadata-file
                                          :operation "complete-task"}
                                   child-count (assoc :archived-children child-count))}]
        (helpers/build-completion-response enhanced-msg-text modified-files use-git? git-result task-data)))))

(defn- description
  "Generate description for complete-task tool based on config."
  [config]
  (str
    "Complete a task by changing :status to :closed.\n"
    (when (:use-git? config)
      "Automatically commits the task changes.\n")
    "\nIdentifies tasks by exact match using task-id or title (title).
   At least one identifier must be provided.

   Parameters:
   - task-id: (optional) Exact task ID
   - title: (optional) Exact task title match
   - category: (optional) For backwards compatibility - verifies task category if provided
   - completion-comment: (optional) Comment appended to task description

   If both task-id and title are provided, they must refer to the same task.
   If only title is provided and multiple tasks have the same title, an error is returned."))

(defn complete-task-tool
  "Tool to complete a task and move it from tasks to complete directory.

  Accepts config parameter containing :use-git? flag. When git mode is enabled,
  returns modified file paths for git commit workflow. When disabled, returns
  only completion message."
  [config]
  {:name "complete-task"
   :description (description config)
   :inputSchema
   {:type "object"
    :properties
    {"task-id"
     {:type "integer"
      :description "Exact task ID to complete"}
     "title"
     {:type "string"
      :description "Exact task title to match"}
     "category"
     {:type "string"
      :description "(Optional) Task category for backwards compatibility - verifies category matches if provided"}
     "completion-comment"
     {:type "string"
      :description "Optional comment to append to the completed task"}}
    :required []}
   :implementation (partial complete-task-impl config)})
(ns mcp-clj.mcp-server.prompts
  "MCP prompt endpoints"
  (:require
    [clojure.string :as str]
    [mcp-clj.log :as log]))

(defn- validate-argument
  "Validate a prompt argument definition"
  [{:keys [name description]}]
  (and (string? name)
       (not (str/blank? name))
       (or (nil? description)
           (string? description))))

(defn- validate-message
  "Validate a prompt message"
  [{:keys [role content]}]
  (and (contains? #{"user" "assistant" "system"} role)
       (or (and (map? content)
                (= "text" (:type content))
                (string? (:text content)))
           (and (map? content)
                (= "resource" (:type content))
                (map? (:resource content))))))

(defn valid-prompt?
  "Validate a prompt definition"
  [{:keys [name description arguments messages] :as prompt}]
  (when (and (string? name)
             (not (str/blank? name))
             (or (nil? description)
                 (string? description))
             (or (nil? arguments)
                 (and (vector? arguments)
                      (every? validate-argument arguments)))
             (vector? messages)
             (every? validate-message messages))
    prompt))

(defn- apply-template
  "Apply template arguments to a message"
  [message arguments]
  (if (and (= "text" (get-in message [:content :type]))
           (seq arguments))
    (update-in message [:content :text]
               (fn [text]
                 (reduce-kv
                   (fn [t k v]
                     (str/replace t (str "{{" (name k) "}}") v))
                   text
                   arguments)))
    message))

(defn prompt-definition
  "Get the prompt definition without implementation details"
  [prompt]
  (select-keys prompt [:name :description :arguments :title]))

(defn list-prompts
  "List available prompts"
  [registry _params]
  (log/info :prompts/list)
  {:prompts (mapv prompt-definition (vals @registry))})

(defn get-prompt
  "Get a specific prompt with optional arguments"
  [registry {:keys [name arguments] :as params}]
  (log/info :prompts/get {:params params})
  (if-let [prompt (get @registry name)]
    (let [messages (if arguments
                     (mapv #(apply-template % arguments) (:messages prompt))
                     (:messages prompt))]
      {:messages messages
       :description (:description prompt)})
    {:content [{:type "text"
                :text (str "Prompt not found: " name)}]
     :isError true}))

(def ^:private repl-prompt
  (valid-prompt?
    {:name "repl"
     :description "Standard REPL prompt for code evaluation"
     :messages [{:role "system"
                 :content {:type "text"
                           :text "You are interacting with a Clojure REPL."}}
                {:role "user"
                 :content {:type "text"
                           :text "Please evaluate {{code}}"}}]
     :arguments [{:name "code"
                  :description "Clojure code to evaluate"
                  :required true}]}))

(def default-prompts
  "Default set of built-in prompts"
  {"repl" repl-prompt})
(ns mcp-tasks.prompts
  "Task management prompts"
  (:require
    [babashka.fs :as fs]
    [clojure.java.io :as io]
    [clojure.string :as str]
    [mcp-clj.mcp-server.prompts :as prompts]))

(defn- parse-frontmatter
  "Parse simple 'field: value' frontmatter from markdown text.

  Expects frontmatter delimited by '---' at start and end.
  Format example:
    ---
    description: Task description
    author: John Doe
    ---
    Content here...

  Returns a map with :metadata (parsed key-value pairs)
  and :content (remaining text).  If no valid frontmatter is found,
  returns {:metadata nil :content <original-text>}."
  [text]
  (if-not (str/starts-with? text "---\n")
    {:metadata nil :content text}
    (let [lines (str/split-lines text)
          ;; Skip first "---" line
          after-start (rest lines)
          ;; Find closing "---"
          closing-idx (first (keep-indexed
                               (fn [idx line]
                                 (when (= "---" (str/trim line)) idx))
                               after-start))]
      (if-not closing-idx
        ;; No closing delimiter, treat as no frontmatter
        {:metadata nil :content text}
        (let [metadata-lines (take closing-idx after-start)
              content-lines (drop (inc closing-idx) after-start)
              ;; Parse "key: value" pairs
              metadata (reduce
                         (fn [acc line]
                           (if-let [[_ k v] (re-matches
                                              #"([^:]+):\s*(.*)"
                                              line)]
                             (assoc acc (str/trim k) (str/trim v))
                             acc))
                         {}
                         metadata-lines)
              content (str/join "\n" content-lines)]
          {:metadata (when (seq metadata) metadata)
           :content content})))))

(defn- discover-prompt-files
  "Discover .md prompt files in a directory.

  Takes a File object and returns a sorted vector of filenames without
  .md extension.  Returns empty vector if directory doesn't exist."
  [dir]
  (if (fs/exists? dir)
    (->> (fs/list-dir dir)
         (filter #(and (fs/regular-file? %)
                       (str/ends-with? (str (fs/file-name %)) ".md")))
         (map #(str/replace (str (fs/file-name %)) #"\.md$" ""))
         sort
         vec)
    []))

(defn discover-categories
  "Discover task categories by reading prompts subdirectory from resolved tasks dir.

  Takes config containing :resolved-tasks-dir. Returns a sorted vector of
  category names (filenames without .md extension) found in the prompts
  subdirectory."
  [config]
  (let [resolved-tasks-dir (:resolved-tasks-dir config)
        prompts-dir (str resolved-tasks-dir "/prompts")]
    (discover-prompt-files prompts-dir)))

(defn- read-task-prompt-text
  "Generate prompt text for reading the next task from a category.
  Config parameter included for API consistency but not currently used."
  [_config _category]
  "- Read the file .mcp-tasks/tasks.ednl

- Find the first incomplete task (marked with `- [ ]`) You can use the
  `select-tasks` tool with `:limit 1` to retrieve the next task without
  executing it.

- Show the task description
")

(defn- default-prompt-text
  "Generate default execution instructions for a category."
  []
  (slurp (io/resource "prompts/default-prompt-text.md")))

(defn- complete-task-prompt-text
  "Generate prompt text for completing and tracking a task.

  Conditionally includes git commit instructions based on
  config :use-git? value."
  [config _category]
  (let [base-text
        "- Mark the completed task as complete using the `complete-task` tool.
  This will update the task's status to :closed and move it from
  .mcp-tasks/tasks.ednl to .mcp-tasks/complete.ednl.

- Summarise any deviations in the execution of the task, compared to the task
  spec.
"
        git-text "\n- Commit the task tracking changes in the .mcp-tasks git repository\n"]
    (if (:use-git? config)
      (str base-text git-text)
      base-text)))

(defn- read-prompt-instructions
  "Read custom prompt instructions from prompts subdirectory in resolved tasks dir.

  Takes config containing :resolved-tasks-dir and category name.

  Returns a map with :metadata and :content keys if the file exists, or
  nil if it doesn't.

  The :metadata key contains parsed frontmatter (may be nil),
  and :content contains the prompt text with frontmatter stripped."
  [config category]
  (let [resolved-tasks-dir (:resolved-tasks-dir config)
        prompt-file (str resolved-tasks-dir "/prompts/" category ".md")]
    (when (fs/exists? prompt-file)
      (parse-frontmatter (slurp prompt-file)))))

(defn create-prompts
  "Generate MCP prompts for task categories.

  Reads prompt instructions from prompts/<category>.md files in resolved tasks
  directory if they exist, otherwise uses default prompt text. Each prompt
  provides complete workflow including task lookup, execution
  instructions, and completion steps.

  Returns a vector of prompt maps suitable for registration with the MCP
  server."
  [config categories]
  (vec
    (for [category categories]
      (let [prompt-data (read-prompt-instructions config category)
            metadata (:metadata prompt-data)
            custom-content (:content prompt-data)
            execution-instructions (or custom-content (default-prompt-text))
            prompt-text (str "Please complete the next "
                             category
                             " task following these steps:\n\n"
                             (read-task-prompt-text config category)
                             execution-instructions
                             (complete-task-prompt-text config category))
            description (or (get metadata "description")
                            (format
                              "Execute the next %s task from .mcp-tasks/tasks.ednl"
                              category))]
        (prompts/valid-prompt?
          {:name (str "next-" category)
           :description description
           :messages [{:role "user"
                       :content {:type "text"
                                 :text prompt-text}}]})))))

(defn category-descriptions
  "Get descriptions for all discovered categories.

  Returns a map of category name to description string. Categories
  without custom prompts or without description metadata will have a
  default description."
  [config]
  (let [categories (discover-categories config)]
    (into {}
          (for [category categories]
            (let [prompt-data (read-prompt-instructions config category)
                  metadata (:metadata prompt-data)
                  description (or (get metadata "description")
                                  (format "Tasks for %s category" category))]
              [category description])))))

(defn prompts
  "Generate all task prompts by discovering categories.

  Accepts config parameter to conditionally include git instructions in prompts.
  Uses :resolved-tasks-dir from config to locate prompts directory.

  Returns a map of prompt names to prompt definitions, suitable for registering
  with the MCP server."
  [config]
  (let [categories (discover-categories config)
        prompt-list (create-prompts config categories)]
    (into {} (map (fn [p] [(:name p) p]) prompt-list))))

;; Story prompt utilities

(defn- list-builtin-story-prompts
  "List all built-in story prompts available in resources.

  Returns a sequence of prompt names (without .md extension) found in
  resources/story/prompts directory."
  []
  (when-let [prompts-url (io/resource "story/prompts")]
    (discover-prompt-files (io/file (.toURI prompts-url)))))

(defn get-story-prompt
  "Get a story prompt by name, with file override support.

  Checks for override file at `.mcp-tasks/story/prompts/<name>.md` first.
  If not found, falls back to built-in prompt from resources/story/prompts.

  Returns a map with:
  - :name - the prompt name
  - :description - from frontmatter
  - :content - the prompt text (with frontmatter stripped)

  Returns nil if prompt is not found in either location."
  [prompt-name]
  (let [override-file (str ".mcp-tasks/story/prompts/" prompt-name ".md")]
    (if (fs/exists? override-file)
      (let [file-content (slurp override-file)
            {:keys [metadata content]} (parse-frontmatter file-content)]
        {:name prompt-name
         :description (get metadata "description")
         :content content})
      (when-let [resource-path (io/resource
                                 (str "story/prompts/" prompt-name ".md"))]
        (let [file-content (slurp resource-path)
              {:keys [metadata content]} (parse-frontmatter file-content)]
          {:name prompt-name
           :description (get metadata "description")
           :content content})))))

(defn list-story-prompts
  "List all available story prompts.

  Returns a sequence of maps with :name and :description for each available
  story prompt, including both built-in prompts and file overrides."
  []
  (let [builtin-prompts (for [prompt-name (list-builtin-story-prompts)
                              :let [prompt (get-story-prompt prompt-name)]
                              :when prompt]
                          {:name (:name prompt)
                           :description (:description prompt)})
        story-dir ".mcp-tasks/story/prompts"
        override-prompts (when (fs/exists? story-dir)
                           (for [file (fs/list-dir story-dir)
                                 :when (and (fs/regular-file? file)
                                            (str/ends-with?
                                              (str (fs/file-name file))
                                              ".md"))]
                             (let [name (str/replace
                                          (str (fs/file-name file))
                                          #"\.md$" "")
                                   {:keys [metadata]} (parse-frontmatter
                                                        (slurp (str file)))]
                               {:name name
                                :description (get metadata "description")})))
        all-prompts (concat override-prompts builtin-prompts)
        seen (atom #{})]
    (for [prompt all-prompts
          :when (not (contains? @seen (:name prompt)))]
      (do
        (swap! seen conj (:name prompt))
        prompt))))

(defn- parse-argument-hint
  "Parse argument-hint from frontmatter metadata.

  The argument-hint format uses angle brackets for required arguments and
  square brackets for optional arguments:
  - <arg-name> - required argument
  - [arg-name] - optional argument
  - [...] or [name...] - variadic/multiple values

  Example: '<story-name> [additional-context...]'

  Returns a vector of argument maps with :name, :description,
  and :required keys."
  [metadata]
  (when-let [hint (get metadata "argument-hint")]
    (vec
      (for [token (re-seq #"<([^>]+)>|\[([^\]]+)\]" hint)
            :let [[_ required optional] token
                  arg-name (or required optional)
                  is-required (some? required)
                  is-variadic (str/ends-with? arg-name "...")
                  clean-name (if is-variadic
                               (str/replace arg-name #"\.\.\.$" "")
                               arg-name)
                  description (cond
                                is-variadic (format
                                              "Optional additional %s (variadic)"
                                              clean-name)
                                is-required (format
                                              "The %s (required)"
                                              (str/replace clean-name "-" " "))
                                :else (format
                                        "Optional %s"
                                        (str/replace clean-name "-" " ")))]]
        {:name clean-name
         :description description
         :required is-required}))))

(defn- append-management-instructions
  "Append branch and worktree management instructions to prompt content.

  Conditionally appends management instruction files based on config flags.
  Only appends to prompts matching target-prompt-name.

  Parameters:
  - content: Base prompt content string
  - prompt-name: Name of the current prompt being processed
  - target-prompt-name: Prompt that should receive the instructions
  - config: Config map with :branch-management? and :worktree-management? flags

  Returns the content with instructions appended if conditions match."
  [content prompt-name target-prompt-name config]
  (cond-> content
    (and (= prompt-name target-prompt-name)
         (:branch-management? config))
    (str "\n\n" (slurp (io/resource "prompts/branch-management.md")))
    (and (= prompt-name target-prompt-name)
         (:worktree-management? config))
    (str "\n\n" (slurp (io/resource "prompts/worktree-management.md")))))

(defn story-prompts
  "Generate MCP prompts from story prompt vars in mcp-tasks.story-prompts.

  For execute-story-task prompt, tailors content based on
  config :branch-management?.

  Returns a map of prompt names to prompt definitions, suitable for registering
  with the MCP server."
  [config]
  (require 'mcp-tasks.story-prompts)
  (let [ns (find-ns 'mcp-tasks.story-prompts)
        prompt-vars (->> (ns-publics ns)
                         vals
                         (filter (fn [v] (string? @v))))]
    (into {}
          (for [v prompt-vars]
            (let [prompt-name (name (symbol v))
                  prompt-content @v
                  {:keys [metadata content]} (parse-frontmatter prompt-content)
                  ;; Tailor execute-story-task content based on config
                  tailored-content
                  (append-management-instructions
                    content
                    prompt-name
                    "execute-story-task"
                    config)
                  description (or (get metadata "description")
                                  (:doc (meta v))
                                  (format "Story prompt: %s" prompt-name))
                  arguments (parse-argument-hint metadata)]

              [prompt-name
               (prompts/valid-prompt?
                 (cond-> {:name prompt-name
                          :description description
                          :messages [{:role "user"
                                      :content {:type "text"
                                                :text tailored-content}}]}
                   (seq arguments) (assoc :arguments arguments)))])))))

(defn task-execution-prompts
  "Generate MCP prompts for general task execution workflows.

  Discovers prompt files from resources/prompts/ directory, excluding:
  - Category instruction files (simple.md, medium.md, etc.)
  - Internal files (default-prompt-text.md)

  Returns a map of prompt names to prompt definitions."
  [config]
  (when-let [prompts-url (io/resource "prompts")]
    (let [prompts-dir (io/file (.toURI prompts-url))
          all-prompts (discover-prompt-files prompts-dir)
          ;; Get category names to filter out
          categories (set (discover-categories config))
          ;; Filter out category instruction files and internal files
          excluded-names (conj categories "default-prompt-text")
          task-prompts (remove excluded-names all-prompts)
          prompts-data (for [prompt-name task-prompts
                             :let [resource-path (io/resource
                                                   (str
                                                     "prompts/"
                                                     prompt-name
                                                     ".md"))]
                             :when resource-path]
                         (let [file-content (slurp resource-path)
                               {:keys [metadata content]} (parse-frontmatter
                                                            file-content)
                               ;; Tailor execute-task content based on config
                               tailored-content
                               (append-management-instructions
                                 content
                                 prompt-name
                                 "execute-task"
                                 config)
                               description (or (get metadata "description")
                                               (format
                                                 "Task execution prompt: %s"
                                                 prompt-name))
                               arguments (parse-argument-hint metadata)]
                           [prompt-name
                            (prompts/valid-prompt?
                              (cond-> {:name prompt-name
                                       :description description
                                       :messages [{:role "user"
                                                   :content {:type "text"
                                                             :text tailored-content}}]}
                                (seq arguments) (assoc
                                                  :arguments
                                                  arguments)))]))]
      (into {} prompts-data))))

(defn category-prompt-resources
  "Generate MCP resources for category prompt files.

  Discovers all available categories and creates a resource for each category's
  prompt file found in prompts/<category>.md within resolved tasks directory.

  Each resource has:
  - :uri \"prompt://category-<category>\"
  - :name \"<category> category instructions\"
  - :description from frontmatter or default
  - :mimeType \"text/markdown\"
  - :text content with frontmatter preserved

  Missing files are gracefully skipped (not included in result).

  Returns a vector of resource maps."
  [config]
  (let [categories (discover-categories config)]
    (->> categories
         (keep (fn [category]
                 (when-let [prompt-data (read-prompt-instructions
                                          config
                                          category)]
                   (let [metadata (:metadata prompt-data)
                         content (:content prompt-data)
                         description (or (get metadata "description")
                                         (format
                                           "Execution instructions for %s category"
                                           category))
                         ;; Reconstruct frontmatter if metadata exists
                         frontmatter (when metadata
                                       (let [lines (keep (fn [[k v]]
                                                           (when v
                                                             (str k ": " v)))
                                                         metadata)]
                                         (when (seq lines)
                                           (str "---\n"
                                                (str/join "\n" lines)
                                                "\n---\n"))))
                         ;; Include frontmatter in text if it exists
                         text (str frontmatter content)]
                     {:uri (str "prompt://category-" category)
                      :name (str category " category instructions")
                      :description description
                      :mimeType "text/markdown"
                      :text text}))))
         vec)))
(ns mcp-tasks.tool.add-task
  "MCP tool for adding new tasks to the task queue.

  This namespace implements the add-task tool, which creates new task records
  and appends them to the tasks.ednl file. Tasks can be added to the end of
  the queue (default) or prepended to the beginning for higher priority.

  The tool integrates with the category system, validating that the specified
  category exists and has corresponding prompt resources. It also supports
  task hierarchies through optional parent-id references.

  Part of the refactored tool architecture where each tool lives in its own
  namespace under mcp-tasks.tool.*, with the main tools.clj acting as a facade."
  (:require
    [cheshire.core :as json]
    [clojure.string :as str]
    [mcp-tasks.prompts :as prompts]
    [mcp-tasks.tasks :as tasks]
    [mcp-tasks.tools.git :as git]
    [mcp-tasks.tools.helpers :as helpers]
    [mcp-tasks.tools.validation :as validation]))

(defn- add-task-impl
  "Implementation of add-task tool.

  Adds a task to tasks.ednl. If prepend is true, adds at the beginning;
  otherwise appends at the end. If parent-id is provided, the task is
  associated with that parent task.

  Error Handling:
  - Tool-level validation errors (e.g., parent not found) are returned directly
    in format: {:error \"...\" :metadata {...}} with :isError true
  - Unexpected errors (e.g., file I/O) are allowed to throw and are caught
    by the MCP server layer, which converts them to MCP error format

  Returns:
  - Git disabled: Two content items (text message + task data JSON)
  - Git enabled: Three content items (text message + task data JSON + git-status JSON)"
  [config _context
   {:keys [category title description prepend type parent-id]}]
  ;; Perform file operations inside lock
  (let [locked-result (helpers/with-task-lock config
                                              (fn []
                                                ;; Sync with remote and load tasks
                                                (let [sync-result (helpers/sync-and-prepare-task-file config)]
                                                  (if (and (map? sync-result) (false? (:success sync-result)))
                                                    ;; sync-result is an error map
                                                    (let [{:keys [error error-type]} sync-result
                                                          tasks-dir (:resolved-tasks-dir config)]
                                                      (helpers/build-tool-error-response
                                                        (case error-type
                                                          :conflict (str "Pull failed with conflicts. Resolve manually in " tasks-dir)
                                                          :network (str "Pull failed: " error)
                                                          (str "Pull failed: " error))
                                                        "add-task"
                                                        {:error-type error-type
                                                         :error-details error
                                                         :tasks-dir tasks-dir}))

                                                    ;; sync-result is the tasks-file path - proceed
                                                    (let [tasks-file sync-result]
                                                      ;; Validate parent-id exists if provided
                                                      (or (when parent-id
                                                            (validation/validate-parent-id-exists parent-id "add-task" nil tasks-file "Parent story not found"
                                                                                                  :additional-metadata {:title title :category category}))

                                                          ;; All validations passed - create task
                                                          (let [task-map (cond-> {:title title
                                                                                  :description (or description "")
                                                                                  :design ""
                                                                                  :category category
                                                                                  :status :open
                                                                                  :type (keyword (or type "task"))
                                                                                  :meta {}
                                                                                  :relations []}
                                                                           parent-id (assoc :parent-id parent-id))
                                                                ;; Add task to in-memory state and get the complete task with ID
                                                                created-task (tasks/add-task task-map :prepend? (boolean prepend))
                                                                ;; Get path info for git operations
                                                                tasks-path (helpers/task-path config ["tasks.ednl"])
                                                                tasks-rel-path (:relative tasks-path)]

                                                            ;; Save to EDNL file
                                                            (tasks/save-tasks! tasks-file)

                                                            ;; Return intermediate data for git operations
                                                            {:created-task created-task
                                                             :tasks-file tasks-file
                                                             :tasks-rel-path tasks-rel-path})))))))]
    ;; Check if locked section returned an error
    (if (:isError locked-result)
      locked-result

      ;; Perform git operations outside lock
      (let [{:keys [created-task tasks-file tasks-rel-path]} locked-result
            use-git? (:use-git? config)
            git-result (when use-git?
                         (let [truncated-title (helpers/truncate-title title)]
                           (git/commit-task-changes (:base-dir config)
                                                    [tasks-rel-path]
                                                    (str "Add task #" (:id created-task) ": " truncated-title))))
            task-data-json (json/generate-string
                             {:task (select-keys
                                      created-task
                                      [:id
                                       :title
                                       :category
                                       :type
                                       :status
                                       :parent-id])
                              :metadata {:file tasks-file
                                         :operation "add-task"}})]

        ;; Build response based on git mode
        (if use-git?
          ;; Git enabled: 3 content items
          {:content [{:type "text"
                      :text (str "Task added to " tasks-file)}
                     {:type "text"
                      :text task-data-json}
                     {:type "text"
                      :text (json/generate-string
                              (cond-> {:git-status (if (:success git-result)
                                                     "success"
                                                     "error")
                                       :git-commit (:commit-sha git-result)}
                                (:error git-result)
                                (assoc :git-error (:error git-result))))}]
           :isError false}

          ;; Git disabled: 2 content items (existing behavior)
          {:content [{:type "text"
                      :text (str "Task added to " tasks-file)}
                     {:type "text"
                      :text task-data-json}]
           :isError false})))))

(defn- add-task-description
  "Build description for add-task tool with available categories and their descriptions."
  [config]
  (let [category-descs (prompts/category-descriptions config)
        categories (sort (keys category-descs))]
    [categories
     (if (seq categories)
       (str "Add a task to tasks.ednl\n\nAvailable categories:\n"
            (str/join "\n"
                      (for [cat categories]
                        (format "- %s: %s" cat (get category-descs cat)))))
       "Add a task to tasks.ednl")]))

(defn add-task-tool
  "Tool to add a task to a specific category.

  Returns two content items:
  1. Text message: 'Task added to <file-path>' for human readability
  2. Structured data (JSON): Map with 'task' and 'metadata' keys

  Success response structure:
  {
    \"task\": {
      \"id\": 42,
      \"title\": \"Example task\",
      \"category\": \"simple\",
      \"type\": \"task\",
      \"status\": \"open\",
      \"parent-id\": null
    },
    \"metadata\": {
      \"file\": \"./.mcp-tasks/tasks.ednl\",
      \"operation\": \"add-task\"
    }
  }

  Error response structure (e.g., parent not found):
  {
    \"error\": \"Parent story not found\",
    \"metadata\": {
      \"attempted-operation\": \"add-task\",
      \"parent-id\": 99,
      \"file\": \"./.mcp-tasks/tasks.ednl\"
    }
  }

  Agent usage: On successful task creation, display the task-id and title to
  the user to confirm the task was added.

  Accepts config parameter for future git-aware functionality."
  [config]
  (let [[categories description] (add-task-description config)]
    {:name "add-task"
     :description description
     :inputSchema
     {:type "object"
      :properties
      {"category"
       {:enum (vec categories)
        :description "The task category name"}
       "title"
       {:type "string"
        :description "The task title"}
       "description"
       {:type "string"
        :description "A description of the task"}
       "type"
       {:enum ["task" "bug" "feature" "story" "chore"]
        :description "The type of task (defaults to 'task')"
        :default "task"}
       "parent-id"
       {:type "integer"
        :description "Optional task-id of parent"}
       "prepend"
       {:type "boolean"
        :description "If true, add task at the beginning instead of the end"}}
      :required ["category" "title"]}
     :implementation (partial add-task-impl config)}))
(ns mcp-tasks.tool.select-tasks
  "MCP tool for querying and retrieving tasks from the task queue.

  This namespace implements the select-tasks tool, which provides flexible
  task filtering and retrieval capabilities. Tasks can be filtered by:
  - task-id: Exact ID match
  - category: Task execution category
  - parent-id: Child tasks of a specific parent
  - title-pattern: Regex or substring matching
  - type: Task type (:task, :bug, :feature, :story, :chore)
  - status: Task status (:open, :closed, :in-progress, :blocked)

  Results are returned with metadata including count and pagination info.
  Supports both single-task lookup (unique: true) and multi-task queries
  with configurable limits.

  Part of the refactored tool architecture where each tool lives in its own
  namespace under mcp-tasks.tool.*, with the main tools.clj acting as a facade."
  (:require
    [cheshire.core :as json]
    [mcp-tasks.response :as response]
    [mcp-tasks.tasks :as tasks]
    [mcp-tasks.tools.helpers :as helpers]))

(defn- select-tasks-impl
  "Implementation of select-tasks tool.

  Accepts optional filters (same as next-task):
  - task-id: Task ID to filter by
  - category: Task category name
  - parent-id: Parent task ID for filtering children
  - title-pattern: Pattern to match task titles (regex or substring)
  - type: Task type (keyword: :task, :bug, :feature, :story, :chore)
  - status: Task status (keyword: :open, :closed, :in-progress, :blocked)

  Additional parameters:
  - limit: Maximum number of tasks to return (default: 5, must be > 0)
  - unique: If true, enforce that 0 or 1 task matches (error if >1)

  Returns JSON-encoded response with tasks vector and metadata.

  Metadata semantics:
  - :open-task-count - total number of matching tasks (before limit applied)
  - :returned-count - number of tasks in the :tasks vector (after limit)
  - :limited? - true when open-task-count > returned-count
  - :completed-task-count - total completed children (only when parent-id provided)

  Examples:
  - Query 100 open tasks with limit=5:
    {:open-task-count 100, :returned-count 5, :limited? true}
  - Query parent with 3 open + 2 closed children, limit=2:
    {:open-task-count 3, :completed-task-count 2, :returned-count 2, :limited? true}
  - Query parent with 1 open + 5 closed children, no limit:
    {:open-task-count 1, :completed-task-count 5, :returned-count 1, :limited? false}"
  [config _context {:keys [task-id category parent-id title-pattern type status limit unique]}]
  (try
    ;; Determine effective limit
    ;; If unique? is true, effective limit is always 1
    ;; Otherwise use provided limit or default to 5
    (let [provided-limit? (some? limit)
          default-limit 5
          requested-limit (or limit default-limit)]

      ;; Validate limit parameter if provided
      (when (and provided-limit? (<= requested-limit 0))
        (let [response-data {:error "limit must be a positive integer (> 0)"
                             :metadata {:provided-limit requested-limit}}]
          (throw (ex-info "Invalid limit parameter"
                          {:response response-data}))))

      ;; Validate limit and unique? compatibility
      ;; Only error if limit was explicitly provided AND is > 1
      (when (and unique provided-limit? (> requested-limit 1))
        (let [response-data {:error "limit must be 1 when unique is true (or omit limit)"
                             :metadata {:provided-limit requested-limit :unique true}}]
          (throw (ex-info "Incompatible parameters"
                          {:response response-data}))))

      (let [effective-limit (if unique 1 requested-limit)
            tasks-path (helpers/task-path config ["tasks.ednl"])
            tasks-file (:absolute tasks-path)
            complete-path (helpers/task-path config ["complete.ednl"])
            complete-file (:absolute complete-path)
            ;; Convert type string to keyword if provided
            type-keyword (when type (keyword type))
            ;; Convert status string to keyword if provided
            status-keyword (when status (keyword status))]

        ;; Load tasks from EDNL file
        (when (helpers/file-exists? tasks-file)
          (tasks/load-tasks! tasks-file :complete-file complete-file))

        ;; Get all matching tasks
        ;; When parent-id is provided, we need to count completed child tasks separately
        (let [query-result (if (and parent-id (nil? status-keyword))
                             ;; Parent-id case without explicit status: query :any, count completed separately
                             (let [all-matching (tasks/get-tasks
                                                  :task-id task-id
                                                  :category category
                                                  :parent-id parent-id
                                                  :title-pattern title-pattern
                                                  :type type-keyword
                                                  :status :any)
                                   {closed :closed non-closed :non-closed}
                                   (group-by #(if (= :closed (:status %)) :closed :non-closed)
                                             all-matching)
                                   completed-count (count closed)]
                               {:tasks (or non-closed [])
                                :completed-task-count completed-count})
                             ;; Normal case or explicit status: use status filter directly
                             {:tasks (tasks/get-tasks
                                       :task-id task-id
                                       :category category
                                       :parent-id parent-id
                                       :title-pattern title-pattern
                                       :type type-keyword
                                       :status status-keyword)
                              :completed-task-count nil})
              non-closed-tasks (:tasks query-result)
              completed-count (:completed-task-count query-result)
              total-matches (count non-closed-tasks)
              limited-tasks (vec (take effective-limit non-closed-tasks))
              result-count (count limited-tasks)]

          ;; Check unique? constraint
          ;; When unique is true and a specific task-id was requested, 0 matches is an error
          (when (and unique (zero? total-matches) task-id)
            (let [response-data {:error "No task found with the specified task-id"
                                 :metadata {:task-id task-id
                                            :file tasks-file}}]
              (throw (ex-info "Task not found"
                              {:response response-data}))))

          ;; Multiple matches with unique is also an error
          (when (and unique (> total-matches 1))
            (let [response-data {:error "Multiple tasks matched but :unique was specified"
                                 :metadata {:open-task-count total-matches
                                            :total-matches total-matches}}]
              (throw (ex-info "unique? constraint violated"
                              {:response response-data}))))

          ;; Build success response
          (let [response-data {:tasks limited-tasks
                               :metadata (cond-> {:open-task-count total-matches
                                                  :returned-count result-count
                                                  :total-matches total-matches
                                                  :limited? (> total-matches result-count)}
                                           ;; Add completed-task-count only when parent-id was provided
                                           completed-count (assoc :completed-task-count completed-count))}]
            {:content [{:type "text"
                        :text (json/generate-string response-data)}]
             :isError false}))))

    (catch clojure.lang.ExceptionInfo e
      ;; Handle validation errors with structured response
      (if-let [response-data (:response (ex-data e))]
        {:content [{:type "text"
                    :text (json/generate-string response-data)}]
         :isError false}
        (response/error-response e)))

    (catch Exception e
      (response/error-response e))))

(defn select-tasks-tool
  "Tool to return multiple tasks with optional filters and limits.

  Accepts optional filters:
  - task-id: Task ID to filter by (returns at most one task)
  - category: Task category name
  - parent-id: Parent task ID for filtering children
  - title-pattern: Pattern to match task titles (regex or substring)
  - type: Task type (task, bug, feature, story, chore)
  - status: Task status (open, closed, in-progress, blocked)
  - limit: Maximum number of tasks to return (default: 5, must be > 0)
  - unique: If true, enforce that 0 or 1 task matches (error if >1)

  All filters are AND-ed together.

  Returns JSON-encoded response:
  Success: {\"tasks\": [...], \"metadata\": {...}}
  Error: {\"error\": \"...\", \"metadata\": {...}}"
  [config]
  {:name "select-tasks"
   :description "Return multiple tasks from tasks.ednl with optional filters and limits"
   :inputSchema
   {:type "object"
    :properties
    {"task-id"
     {:type "integer"
      :description "Task ID to filter by (returns at most one task)"}
     "category"
     {:type "string"
      :description "The task category name"}
     "parent-id"
     {:type "integer"
      :description "Parent task ID for filtering children"}
     "title-pattern"
     {:type "string"
      :description "Pattern to match task titles (regex or substring)"}
     "type"
     {:type "string"
      :enum ["task" "bug" "feature" "story" "chore"]
      :description "Task type to filter by"}
     "status"
     {:type "string"
      :enum ["open" "closed" "in-progress" "blocked"]
      :description "Task status to filter by"}
     "limit"
     {:type "integer"
      :description "Maximum number of tasks to return (default: 5, must be > 0)"}
     "unique"
     {:type "boolean"
      :description "If true, enforce that 0 or 1 task matches (error if >1)"}}
    :required []}
   :implementation (partial select-tasks-impl config)})
;; Explicitly require all tool namespaces so bb uberscript includes them
(require 'mcp-tasks.tool.select-tasks)
(require 'mcp-tasks.tool.add-task)
(require 'mcp-tasks.tool.complete-task)
(require 'mcp-tasks.tool.update-task)
(require 'mcp-tasks.tool.delete-task)
(require 'mcp-tasks.cli)

(apply mcp-tasks.cli/-main *command-line-args*)
